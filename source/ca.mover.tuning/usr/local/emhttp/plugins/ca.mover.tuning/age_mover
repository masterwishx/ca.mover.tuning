#!/bin/bash
#Copyright (C)
#      2005-2024, Lime Technology, Inc. (any and all other parts of Unraid)
#      2018 - Andrew Zawadzki (parts of code from mover tuning package)
#      2023 - hugenbd (parts of code from mover tuning package)
#      2024 - R3yn4ld (parts of code from mover tuning package)
#      2025 - masterwishx (as current author and maintainer of this file)
#License: GPLv2 only

# This is the 'mover tuning' script used for moving files between the cache disk and main array.
# It is typically invoked via cron.

# First we check if it's valid for this script run: there must be a cache disk present and
# an instance of the script must not already be running.

# Next, check each of the top-level directories (shares) on the cache disk.
# For all share with 'Use Cache' setting set to "prefer" or "yes", we use 'find' to
# create a filtered file list of that share directory.
# For all share with 'Use Cache' setting set to "only", we use 'du' or 'zfs list' to
# get total size of that share directory.

# The list is sorted by "Use cache", increasing age, pool, and file inode, giving priority for being
# on cache to "cache only" shares, then "cache prefer" by moving newest from array to cache and older to array,
# and finally to "cache yes" share by moving only from cache to array.
# Please note that if age setting is set to something else than "Auto (smart cache)" this script is actually
# dumb and do not check for size and free space and rely on your own calculations.
# Files at the top level of the cache or an array disk (i.e not in a share) are never moved.

# The list is then passed to original unraid mover.
# For each file, if the file is not "in use" by any process (as detected by 'fuser' command),
# then the file is moved, and upon success, deleted from the source disk.  If the file already
# exists on the target, it is not moved and the sourceis not deleted.  All meta-data of moved
# files/directories is preserved: permissions, ownership, extended attributes, and access/modified
# timestamps.

# If an error occurs in copying a file, the partial file, if present, is deleted and the
# operation continues on to the next file.

PIDFILE="/var/run/mover.pid"
SOFTSTOPFILE="/var/run/moversoft.stop"
SOFTSTOP_ACK=false
UNRAIDCFGFILE="/boot/config/share.cfg"
MOVERTUNINGCFGFILE="/boot/config/plugins/ca.mover.tuning/ca.mover.tuning.cfg"
MOVERTUNING_OVERRIDE_CFGFOLDER="/boot/config/plugins/ca.mover.tuning/shareOverrideConfig"
MOVERTUNING_DEFAULT_CFGFILE="/usr/local/emhttp/plugins/ca.mover.tuning/default.cfg"
LOGLEVEL=1
DEBUGLEVEL=1
TOTALPRIMARYFILES=0
REMAININGPRIMARYFILES=0
TOTALPRIMARYSIZE=0
REMAININGPRIMARYSIZE=0
TOTALSECONDARYFILES=0
REMAININGSECONDARYFILES=0
TOTALSECONDARYSIZE=0
REMAININGSECONDARYSIZE=0
TOTALUNATTENDEDFILES=0
TOTALUNATTENDEDSIZE=0
REMAININGUNATTENDEDFILES=0
REMAININGUNATTENDEDSIZE=0
COUNT_SECONDARY_FILES=0
overrideFlag=0
# PHP requires escaped quotes (" -> \") for text fields
DEFAULT_INVALID_FILE_CHARS=('$' '/' '<' '>' ':' '\"' '|' '?' '*')
# Variables for counts when delete folders
LAST_DIR=""
LAST_COUNT=-1
# Variables from unraid mover.old empty() function
DEBUGGING=""
CFGPATH="/boot/config/shares"
move() {
    find "$1" -depth 2>/dev/null | /usr/libexec/unraid/move $2 $DEBUGGING
    # second pass to clean up leftover empty directories
    find "$1" -depth -type d 2>/dev/null | /usr/libexec/unraid/move $2 $DEBUGGING
}
#

# Get parent Logs Folder from config, if blank set to default /tmp
CONFIGLOGFOLDER=$(grep "loggingFolder=" "$MOVERTUNINGCFGFILE" | cut -d '"' -f 2)

if [ -z "$CONFIGLOGFOLDER" ]; then
    LOGFOLDER="/tmp"
else
    LOGFOLDER="$CONFIGLOGFOLDER"
fi

NOW=$(date +"%FT%H%M%S")
FILTERED_FILELIST="${LOGFOLDER}/ca.mover.tuning/Filtered_files_$NOW.list"
MOVER_ACTIONLIST="${LOGFOLDER}/ca.mover.tuning/Mover_action_$NOW.list"
STATS_FILE="${LOGFOLDER}/ca.mover.tuning/Summary_$NOW.txt"
MOVER_STATUS="/usr/local/emhttp/state/mover.ini"
MOVER_LOG="${LOGFOLDER}/ca.mover.tuning/Mover_tuning_$NOW.log"
MOVER_DEBUG_LOG="${LOGFOLDER}/ca.mover.tuning/Debug_Mover_tuning_$NOW.log"
GUI_CURRENT_FILE=""
GUI_ACTION="Calculating"

# This function is to send messages to Unraid gui etc.
function unraid_notify() {
    local message="$1"
    local flag="$2"
    #
    # Check the notification_type variable
    if [[ "$NOTIFY" == "no" ]]; then
        mvDebuglogger "No notify mode activated. Notifications are disabled." "Notify Mode"
        return 0 # Exit the function if notification_type is set to 'none'
    fi
    #
    # In Errors Only mode, only send 'failure', exit the function
    if [[ "$NOTIFY" == "errorsOnly" && "$flag" != "failure" ]]; then
        mvDebuglogger "Errors Only notify mode activated. Success/Warning notifications are disabled." "Notify Mode"
        return 0 # Do not process success messages
    fi
    #
    # In Moved Only mode, suppress success/warning when nothing moved, exit the function
    if [[ "$NOTIFY" == "movedOnly" ]] && [[ "$flag" == "success" || "$flag" == "warning" ]]; then
        if [[ "$TOTALFILES" -eq 0 ]]; then
            mvDebuglogger "Moved Only notify mode activated. No files were moved, and notifications are disabled." "Notify Mode"
            return 0 # Do not process success messages
        else
            mvDebuglogger "Moved Only notify mode activated. Files were moved, and notifications are enabled." "Notify Mode"
        fi
    else
        mvDebuglogger "Yes notify mode activated. All notifications are enabled." "Notify Mode"
    fi
    #
    # Determine the severity of the message based on the flag it received
    local severity
    if [[ "$flag" == "success" ]]; then
        severity="normal"
    else
        severity="warning"
    fi
    #
    # Call the Unraid notification script
    /usr/local/emhttp/webGui/scripts/notify -s "Mover Tuning Notification" -d "$message" -i "$severity" -l "/Settings/Scheduler"
}

function is_zfs_mountpoint_fstype() {
    local result
    result=$(findmnt "$1" -o fstype | tail -n 1)
    [ "$result" = "zfs" ]
    return
}

function titleLine() {
    local title="$1"
    local padding_char="$2"
    local line_length=71
    local padding_left=$((line_length - ${#title} / 2))
    local padding_right=$((padding_left - ${#title} % 2 - 1))
    left_padding=$(printf "%*s" "$padding_left" "" | tr ' ' "$padding_char")
    right_padding=$(printf "%*s" "$padding_right" "" | tr ' ' "$padding_char")
    echo "${left_padding}$padding_char $title $padding_char${right_padding}"
}

# Function to convert byte size to human-readable format
function bytes_to_human() {
    echo "$(numfmt $1 --to=iec-i)B"
}

function human_to_bytes() {
    echo "$(numfmt $1 --from=iec)"
}

# Sanitize input filename to prevent attacks
function validate_filename() {
    local filename="$1"

    ## Check filename length
    if [[ ${#filename} -gt 255 ]]; then
        mvlogger "Error: Filename too long: '$filename'"
        return 1
    fi

    # Invalid characters (Linux + Windows + macOS safe)
    if [[ "$filename" == *["$INVALID_FILE_CHARS_STR"]* ]]; then
        mvlogger "Error: Invalid characters in filename: '$filename'"
        return 1
    fi

    # Fast path traversal detection
    if [[ "$filename" == *".."* ]]; then
        # Only block if '..' is used as a path segment
        if [[ "$filename" == "../"* || "$filename" == *"/.."* || "$filename" == "..\\"* || "$filename" == *"\\.."* ]]; then
            mvlogger "Error: Path traversal attempt detected: '$filename'"
            return 1
        fi
    fi

    return 0
}

# Function for verbose output and logging
mvlogger() {

    if [ ! -d "${LOGFOLDER}/ca.mover.tuning" ]; then
        echo "${LOGFOLDER}/ca.mover.tuning Directory does not exist. Creating it"
        mkdir -p "${LOGFOLDER}/ca.mover.tuning"
    fi

    if [ $LOGLEVEL = 1 ]; then
        if [ -t 1 ]; then # running from terminal, echoing date
            echo "$(date +"%T.%3N") $1"
        else # running from cron
            echo "$1"
        fi
        echo "$(date +"%T.%3N") $1" >>"$MOVER_LOG"
    fi

    # if $2 exist send notify message
    if [ -n "$2" ]; then
        unraid_notify "$1" "$2"
    fi
}

# Function for verbose debug output and debug logging
# $1 is the debug message to log
# $2 is the name of debug message
mvDebuglogger() {
    if [ "$DEBUGLEVEL" = 1 ]; then

        local msg="$1"
        local tag="$2"

        # Terminal output
        if [ -t 1 ]; then # interactive terminal ⇒ show timestamp
            printf '%s\n' "$(titleLine "Debugging $tag" '-')"
            printf '%s\n' "$(date +"%T.%3N") $msg"
            printf '%s\n' "$(titleLine " " ' ')"
        else # cron/non-interactive ⇒ plain echo
            printf '%s\n' "$(titleLine "Debugging $tag" '-')"
            printf '%s\n' "$msg"
            printf '%s\n' "$(titleLine " " ' ')"
        fi

        # Log file output (always with timestamp)
        {
            printf '%s\n' "$(titleLine "Debugging $tag" '-')"
            printf '%s\n' "$(date +"%T.%3N") $msg"
            printf '%s\n' "$(titleLine " " ' ')"
        } >>"$MOVER_DEBUG_LOG"
    fi
}

#Moved variable assignment into a function
getMoverSettings() {
    #Use the config file instead of input variables (ease execution from command line)
    local config_file="$1"
    cfg() {
        local param="$1"
        local value
        while IFS='=' read -r key val; do
            [ "$key" == "$param" ] && {
                value="$val"
                break
            }
        done <"$config_file"
        #echo "${value//\"/}" # Print value or empty string if not found, without quotes

        # Strip only *outer* quotes, keep inner ones
        value="${value%\"}" # remove trailing "
        value="${value#\"}" # remove leading "
        echo "$value"
    }

    timezone=$(grep "timeZone=" "/boot/config/ident.cfg" | cut -d '"' -f 2)

    if [[ ! -f "$config_file" ]]; then
        mvlogger "Error: Config file '$config_file' not found." "failure"
        return 1
    fi

    ## Read in default threshold limit.
    ## [[ ! "$config_file" =~ shareOverrideConfig ]] ensure that we are not reading share custom settings

    if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
        MOVINGPCTTHRESHOLD=$(cfg movingThreshold)
        [ -z $MOVINGPCTTHRESHOLD ] && MOVINGPCTTHRESHOLD=85
        mvlogger "Using global (cache:yes) moving threshold: $MOVINGPCTTHRESHOLD %"
    elif [ -n "$(cfg movingThreshold)" ]; then
        MOVINGPCTTHRESHOLD=$(cfg movingThreshold)
        mvlogger "Using share (cache:yes) moving threshold: $MOVINGPCTTHRESHOLD %"
    fi

    if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
        FREEINGPCTLIMIT=$(cfg freeingThreshold)
        if [ -z $FREEINGPCTLIMIT ]; then
            FREEINGPCTLIMIT=25
            echo "freeingThreshold=\"$FREEINGPCTLIMIT\"" >>$config_file
        fi
        mvlogger "Using global (cache:yes) freeing threshold: $FREEINGPCTLIMIT %"
    elif [ -n "$(cfg freeingThreshold)" ]; then
        FREEINGPCTLIMIT=$(cfg freeingThreshold)
        mvlogger "Using share (cache:yes) freeing threshold: $FREEINGPCTLIMIT %"
    fi

    if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
        PREFER_FILLUPPCTLIMIT=$(cfg fillupThreshold)
        PREFER_MOVINGPCTTHRESHOLD=0
        if [ -z $PREFER_FILLUPPCTLIMIT ]; then
            PREFER_FILLUPPCTLIMIT=95
            echo "fillupThreshold=\"$PREFER_FILLUPPCTLIMIT\"" >>$config_file
        fi
        mvlogger "Using global (cache:prefer) fillup threshold: $PREFER_FILLUPPCTLIMIT %"
    elif [ -n "$(cfg fillupThreshold)" ]; then
        PREFER_FILLUPPCTLIMIT=$(cfg fillupThreshold)
        PREFER_MOVINGPCTTHRESHOLD=0
        mvlogger "Using share (cache:prefer) fillup threshold: $PREFER_FILLUPPCTLIMIT %"
    fi

    # Read other thresholds
    if [ -z $(cfg omovercfg) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Move All from Primary->Secondary shares argument provided, defaulting to no"
            echo 'omovercfg="no"' >>$config_file
            OMOVERTHRESH=""
        fi
    else
        if [ $(cfg omovercfg) = "yes" ]; then
            OMOVERTHRESH=$(cfg omoverthresh)
            [ -n "$OMOVERTHRESH" ] && mvlogger "Primary threshold to Move all Primary->Secondary shares to secondary: $OMOVERTHRESH %"
        else
            [[ ! "$config_file" =~ shareOverrideConfig ]] && OMOVERTHRESH=""
        fi
    fi

    # Read filters parameters
    if [ -z $(cfg age) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Age argument provided, defaulting to no"
            echo 'age="no"' >>$config_file
            AGE=0
        fi
    else
        if [ $(cfg age) = "yes" ]; then
            AGE=$(cfg daysold)
            if [ $AGE -eq -1 ]; then
                mvlogger "Age: Automatic (smart caching)"
            else
                mvlogger "Age: $AGE"
            fi
        else
            AGE=0
            mvlogger "Age: $(cfg age) = $AGE ; daysold: $(cfg daysold)"
        fi
    fi

    if [ -z $(cfg afterScript) ]; then
        #mvlogger "No After Script argument provided"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && AFTERSCRIPT=""
    else
        AFTERSCRIPT=$(cfg afterScript)
        mvlogger "After script: $AFTERSCRIPT"
    fi

    if [ -z $(cfg beforeScript) ]; then
        #mvlogger "No Before Script argument provided"
        [[ ! "$config_file" =~ shareOverrideConfig ]] && BEFORESCRIPT=""
    else
        BEFORESCRIPT=$(cfg beforeScript)
        mvlogger "Before script: $BEFORESCRIPT"
    fi

    if [ -z $(cfg cleanFolders) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Clean folders argument provided, defaulting to no"
            CLEANFOLDERS="no"
            echo 'cleanFolders="no"' >>$config_file
        fi
    else
        CLEANFOLDERS=$(cfg cleanFolders)
        if [[ $CLEANFOLDERS = "yes" || $CLEANFOLDERS = "topFolder" ]]; then
            mvlogger "Clean Folders: $CLEANFOLDERS"
        fi
    fi

    if [ -z $(cfg cleanDatasets) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Clean ZFS datasets argument provided, defaulting to no"
            CLEANDATASETS="no"
            echo 'cleanDatasets="no"' >>$config_file
        fi
    else
        CLEANDATASETS=$(cfg cleanDatasets)
        if [ $CLEANDATASETS = "yes" ]; then
            mvlogger "Clean ZFS datasets: $CLEANDATASETS"
        fi
    fi

    if [ -z $(cfg ctime) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No CTIME argument provided, defaulting to no"
            CTIME="no"
            echo 'ctime="no"' >>$config_file
        fi
    else
        CTIME=$(cfg ctime)
        [ $CTIME = "yes" ] && mvlogger "CTIME: $CTIME"
    fi

    if [ -z $(cfg atime) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No ATIME argument provided, defaulting to no"
            ATIME="no"
            echo 'atime="no"' >>$config_file
        fi
    else
        ATIME=$(cfg atime)
        [ $ATIME = "yes" ] && mvlogger "ATIME: $ATIME"
    fi

    if [ -z $(cfg enableTurbo) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Turbo Mode argument provided, defaulting to no"
            ENABLETURBO="no"
            echo 'enableTurbo="no"' >>"$config_file"
        fi
    else
        ENABLETURBO=$(cfg enableTurbo)
        [ $ENABLETURBO = "yes" ] && mvlogger "Enable Turbo: $ENABLETURBO"
    fi

    if [ -z $(cfg filelistf) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Skipfiles argument provided, defaulting to no"
            echo 'filelistf="no"' >>$config_file
        fi
    else
        if [ $(cfg filelistf) = "yes" ]; then
            SKIPFILESLIST=$(cfg filelistv)
            mvlogger "Skip file list: $SKIPFILESLIST"
        else
            [[ ! "$config_file" =~ shareOverrideConfig ]] && SKIPFILESLIST=""
        fi
    fi

    if [ -z $(cfg filetypesf) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Skip File Types argument provided, defaulting to no"
            echo 'filetypesf="no"' >>$config_file
            SKIPFILETYPES=""
        fi
    else
        if [ $(cfg filetypesf) = "yes" ]; then
            ###echo "Skipfiletypes supplied"
            SKIPFILETYPES=$(cfg filetypesv)
            SKIPFILETYPES=$(echo "$SKIPFILETYPES" | awk -F, '{for(i=1;i<=NF;i++) {gsub(/\.| /, "", $i); printf "%s%s", $i, (i<NF?" ":"")}}')
            mvlogger "Skip filetypes: $SKIPFILETYPES"
        else
            [[ ! "$config_file" =~ shareOverrideConfig ]] && SKIPFILETYPES=""
        fi
    fi

    if [ -z $(cfg ignoreHidden) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Ignore Hidden Files argument provided, defaulting to no"
            echo 'ignoreHidden="no"' >>$config_file
            IGNOREHIDDENFILES="no"
        fi
    else
        IGNOREHIDDENFILES=$(cfg ignoreHidden)
        [ $IGNOREHIDDENFILES = "yes" ] && mvlogger "Ignore Hidden Files: $IGNOREHIDDENFILES"
    fi

    if [ -z $(cfg rebalanceShares) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Rebalance argument provided, defaulting to no"
            echo 'rebalanceShares="no"' >>$config_file
            REBALANCESHARES="no"
        fi
    else
        REBALANCESHARES=$(cfg rebalanceShares)
        [ $REBALANCESHARES != "no" ] && mvlogger "Rebalance shares: $REBALANCESHARES"
        [ $REBALANCESHARES = "run-once" ] && REBALANCESHARES="yes"
    fi

    if [ -z $(cfg sizef) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Size argument provided, defaulting to no"
            echo 'sizef="no"' >>$config_file
            SIZE=0
        fi
    else
        if [ $(cfg sizef) = "yes" ]; then
            SIZE=$(cfg sizeinM)
            [ $SIZE -gt 0 ] && mvlogger "Move Size supplied: $SIZE"
        else
            [[ ! "$config_file" =~ shareOverrideConfig ]] && SIZE=0
        fi
    fi

    if [ -z $(cfg sparsnessf) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Sparness argument provided, defaulting to no"
            echo 'sparsnessf="no"' >>$config_file
            SPARSENESS=0
        fi
    else
        if [ $(cfg sparsnessf) = "yes" ]; then
            SPARSENESS=$(cfg sparsnessv)
            [ $SPARSENESS -gt 0 ] && mvlogger "Sparness supplied: $SPARSENESS"
        else
            [[ ! "$config_file" =~ shareOverrideConfig ]] && SPARSENESS=0
        fi
    fi

    if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
        SYNCHRONIZECACHE=$(cfg synchronizeCache)
        if [ -z $(cfg synchronizeCache) ]; then
            mvlogger "No Synchronize Primary to Secondary argument provided, defaulting to no"
            echo 'synchronizeCache="no"' >>$config_file
            SYNCHRONIZECACHE="no"
        fi

    elif [ -n "$(cfg synchronizeCache)" ]; then
        SYNCHRONIZECACHE=$(cfg synchronizeCache)
    fi

    if [ "$SYNCHRONIZECACHE" = "yes" ]; then
        LASTCACHESYNC=$(cfg lastCacheSync)
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            [ -z "$LASTCACHESYNC" ] && LASTCACHESYNC=0
            mvlogger "Synchronize global Primary to Secondary: $SYNCHRONIZECACHE - Last sync date: $(TZ=$timezone date +%FT%H%M%S -d "@$LASTCACHESYNC")"
        else
            [ -z "$LASTCACHESYNC" ] && LASTCACHESYNC=0
            mvlogger "Synchronize share Primary to Secondary: $SYNCHRONIZECACHE - Last sync date: $(TZ=$timezone date +%FT%H%M%S -d "@$LASTCACHESYNC")"
        fi
    fi

    if [ -z $(cfg resynchronizeCache) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Resynchronize argument provided, defaulting to no"
            echo 'resynchronizeCache="no"' >>$config_file
            RESYNCHRONIZECACHE="no"
        fi
    else
        RESYNCHRONIZECACHE=$(cfg resynchronizeCache)
        if [ $RESYNCHRONIZECACHE != "no" ]; then
            mvlogger "Resynchronize Primary to Secondary: $RESYNCHRONIZECACHE"
        fi
        [ $RESYNCHRONIZECACHE = "run-once" ] && RESYNCHRONIZECACHE="yes"
    fi

    if [ -z $(cfg sizefSync) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Sync Size argument provided, defaulting to no"
            echo 'sizefSync="no"' >>$config_file
            SYNC_SIZE=0
        fi
    else
        if [ $(cfg sizefSync) = "yes" ]; then
            SYNC_SIZE=$(cfg sizeinMSync)
            [ $SYNCHRONIZECACHE == "yes" ] || [ $RESYNCHRONIZECACHE == "yes" ] && [ $SYNC_SIZE -gt 0 ] && mvlogger "Sync Size supplied: $SYNC_SIZE"
        else
            [[ ! "$config_file" =~ shareOverrideConfig ]] && SYNC_SIZE=0
        fi
    fi

    if [ -z $(cfg testmode) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Test Mode argument provided, defaulting to no"
            echo 'testmode="no"' >>$config_file
            TESTMODE="no"
        fi
    else
        TESTMODE=$(cfg testmode)
        [ $TESTMODE = "yes" ] && mvlogger "Test Mode: $TESTMODE"
    fi

    if [ -z $(cfg notify) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Notify argument provided, defaulting to yes"
            echo 'notify="yes"' >>$config_file
            NOTIFY="yes"
        fi
    else
        NOTIFY=$(cfg notify)
        mvlogger "Notify: $NOTIFY"
    fi

    if [ -z $(cfg logging) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Logging argument provided, defaulting to yes"
            echo 'logging="yes"' >>$config_file
            LOGLEVEL=1
        fi
    else
        if [ $(cfg logging) = "no" ]; then
            LOGLEVEL=0
        else
            LOGLEVEL=1
        fi
        mvlogger "Logging: $(cfg logging)"
    fi

    if [ -z $(cfg debuglogging) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Debug Logging argument provided, defaulting to no"
            echo 'debuglogging="no"' >>$config_file
            DEBUGLEVEL=0
        fi
    else
        if [ $(cfg debuglogging) = "no" ]; then
            DEBUGLEVEL=0
        else
            DEBUGLEVEL=1
        fi
        mvlogger "Debug Logging: $(cfg debuglogging)"
    fi

    if [ -z $(cfg loggingFolder) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Log parent folder argument provided, defaulting to /tmp"
            echo 'loggingFolder="/tmp"' >>$config_file
            LOGFOLDER="/tmp"
        fi
    else
        LOGFOLDER=$(cfg loggingFolder)
        mvlogger "Log parent folder: $LOGFOLDER"
    fi

    if [ -z $(cfg logfilesDaysold) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Log files delete age argument provided, defaulting to 5 days"
            echo 'logfilesDaysold="5"' >>$config_file
            LOGFILESAGE=5
        fi
    else
        LOGFILESAGE=$(cfg logfilesDaysold)
        mvlogger "Log files delete age: $LOGFILESAGE days"
    fi

    if [ -z $(cfg listfilesDaysold) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No List files delete age argument provided, defaulting to 10 days"
            echo 'listfilesDaysold="10"' >>$config_file
            LISTFILESAGE=10
        fi
    else
        LISTFILESAGE=$(cfg listfilesDaysold)
        mvlogger "List files delete age: $LISTFILESAGE days"
    fi

    if [ -z $(cfg validateFilenames) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Validate Filenames argument provided, defaulting to yes"
            echo 'validateFilenames="yes"' >>$config_file
            VALIDATE_FILENAMES="yes"
        fi
    else
        VALIDATE_FILENAMES=$(cfg validateFilenames)
        mvlogger "Validate Filenames: $VALIDATE_FILENAMES"
    fi

    if [ -z "$(cfg invalidFileChars)" ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            # Print and unescape the array element \" -> "
            mvlogger "No Invalid characters argument provided, defaulting to: ${DEFAULT_INVALID_FILE_CHARS[*]//\\\"/\"}"
            echo "invalidFileChars=\"${DEFAULT_INVALID_FILE_CHARS[*]}\"" >>$config_file
            # Keep DEFAULT_INVALID_FILE_CHARS as an array
            INVALID_FILE_CHARS=("${DEFAULT_INVALID_FILE_CHARS[@]}")
            # Escape regex meta chars, first remove '\' from '\"', then add '\' to all characters
            INVALID_FILE_CHARS_STR=$(printf '%s' "${INVALID_FILE_CHARS[@]//\\\"/\"}" | sed 's/./\\&/g')
        fi
    else
        # Convert the string from cfg invalidFileChars to an array
        IFS=' ' read -r -a INVALID_FILE_CHARS <<<"$(cfg invalidFileChars)"
        # Print and unescape the array element \" -> "
        mvlogger "Invalid characters to block: ${INVALID_FILE_CHARS[*]//\\\"/\"}"
        # Escape regex meta chars, first remove '\' from '\"', then add '\' to all characters
        INVALID_FILE_CHARS_STR=$(printf '%s' "${INVALID_FILE_CHARS[@]//\\\"/\"}" | sed 's/./\\&/g')
    fi

    if [ -z $(cfg movefilesTool) ]; then
        if [[ ! "$config_file" =~ shareOverrideConfig ]]; then
            mvlogger "No Move files tool argument provided, defaulting to rsync"
            MOVE_FILES_TOOL="rsync"
            echo 'movefilesTool="rsync"' >>$config_file
        fi
    else
        MOVE_FILES_TOOL=$(cfg movefilesTool)
        mvlogger "Move files tool: $MOVE_FILES_TOOL"
    fi
}

resetRunOnceMoverSettings() {
    local config_file="$1"

    if grep -q "run-once" "$config_file"; then
        mvlogger "Reset 'Run-once' settings to 'no' in $config_file"
        sed 's|"run-once"|"no"|g' -i "$config_file"
        #else
        #mvlogger "No run-once settings to reset in $config_file"
    fi
}

moverStatusWrite() {
    #echo "test write"
    #Writes to file /usr/local/emhttp/state/mover.ini GUI update variables
    echo "TotalToSecondary=${TOTALPRIMARYSIZE}" >$MOVER_STATUS
    echo "RemainToSecondary=${REMAININGPRIMARYSIZE}" >>$MOVER_STATUS

    echo "TotalFromSecondary=${TOTALSECONDARYSIZE}" >>$MOVER_STATUS
    echo "RemainFromSecondary=${REMAININGSECONDARYSIZE}" >>$MOVER_STATUS

    echo "TotalFromUnattended=${TOTALUNATTENDEDSIZE}" >>$MOVER_STATUS
    echo "RemainFromUnattended=${REMAININGUNATTENDEDSIZE}" >>$MOVER_STATUS

    echo "TotalFilesToSecondary=${TOTALPRIMARYFILES}" >>$MOVER_STATUS
    echo "RemainFilesToSecondary=${REMAININGPRIMARYFILES}" >>$MOVER_STATUS

    echo "TotalFilesFromSecondary=${TOTALSECONDARYFILES}" >>$MOVER_STATUS
    echo "RemainFilesFromSecondary=${REMAININGSECONDARYFILES}" >>$MOVER_STATUS

    echo "TotalFilesFromUnattended=${TOTALUNATTENDEDFILES}" >>$MOVER_STATUS
    echo "RemainFilesFromUnattended=${REMAININGUNATTENDEDFILES}" >>$MOVER_STATUS

    echo "File=${GUI_CURRENT_FILE}" >>$MOVER_STATUS
    echo "Action=${GUI_ACTION}" >>$MOVER_STATUS
}

createFilteredFilelist() {
    mvlogger "$(titleLine 'FILTERING FILES' '*')"

    # create a file containing the list off all shareUseCache yes or prefer whith this format:
    echo "PRIMARYSTORAGENAME|SECONDARYSTORAGENAME|SHARENAME|SHAREUSECACHE|MODIFICATIONTIME|PRIMARYSIZETHRESH|FILESIZE|SPARSENESS|NBLINKS|INODE|FILEPATH" >"$FILTERED_FILELIST"

    for SHARECFG in "$CFGPATH"/*.cfg; do
        if [ -e $SOFTSTOPFILE ]; then
            [ $SOFTSTOP_ACK = true ] || mvlogger "Soft Stopping requested" && SOFTSTOP_ACK=true
            return
        fi

        globalSkipFileTypes=$SKIPFILETYPES

        #Gathering information
        #Sharename
        SHARENAME="$(basename "$SHARECFG" .cfg)"
        # Share title line
        mvlogger "$(titleLine "Processing [$SHARENAME] share" '-')"

        #Check to see if this share has a mover settings override, if yes set overrideFlag and change settings
        if [ -f "${MOVERTUNING_OVERRIDE_CFGFOLDER}/${SHARENAME}.cfg" ]; then
            SHARETUNINGFILE="${MOVERTUNING_OVERRIDE_CFGFOLDER}/${SHARENAME}.cfg"
            if grep -qs 'moverOverride="yes"' "$SHARETUNINGFILE"; then
                overrideFlag=1
                mvlogger "Settings override:"
                mvlogger "------------------"
                getMoverSettings "$SHARETUNINGFILE"
                mvlogger "------------------------------------------------------------------------"
            fi
        elif [ $overrideFlag = 1 ]; then
            #else if overrideFLag set from previous loop then restore global settings
            overrideFlag=0
            #Get Mover Tuning Settings
            mvlogger "Restore global settings"
            mvlogger "-----------------------"
            getMoverSettings "$MOVERTUNINGCFGFILE"
            mvlogger "------------------------------------------------------------------------"
        fi

        # Determine Cache mode
        SHAREUSECACHE=$(grep shareUseCache "$SHARECFG" | cut -d'=' -f 2 | tr -d '"' | tr -d '\r')

        # Determine primary storage
        PRIMARYSTORAGENAME=$(grep "shareCachePool=" "$SHARECFG" | cut -d'=' -f 2 | tr -d '"' | tr -d '\r')
        if [ -z "$PRIMARYSTORAGENAME" ]; then
            PRIMARYSTORAGENAME="user0"
        fi
        # Check if the storage exists
        if [ ! -d "/mnt/$PRIMARYSTORAGENAME" ]; then
            # Do not process this pool if path does not exist
            mvlogger "/mnt/$PRIMARYSTORAGENAME does not exist. Is the pool still used? Consider removing $SHARECFG if not."
            mvlogger "=> Skipping"
            continue # Move to the next iteration of the loop
        fi

        # Determine secondary storage
        SECONDARYSTORAGENAME=$(grep "shareCachePool2=" "$SHARECFG" | cut -d'=' -f 2 | tr -d '"' | tr -d '\r')
        if [ -z "$SECONDARYSTORAGENAME" ]; then
            if [ "$SHAREUSECACHE" = "only" ] || [ "$SHAREUSECACHE" = "no" ]; then
                SECONDARYSTORAGENAME="none"
            else
                SECONDARYSTORAGENAME="user0"
            fi
        fi

        # Find the current percent of used size of pool.
        if is_zfs_mountpoint_fstype "/mnt/$PRIMARYSTORAGENAME"; then
            #mvlogger "$PRIMARYSTORAGENAME is zfs."
            POOLPCTUSED=$(zfs list -Hpo available,used "$PRIMARYSTORAGENAME" | awk '{print int(($2 / ($1 + $2)) * 100)}')
            POOLBYTEUSED=$(zfs list -Hpo used "$PRIMARYSTORAGENAME")
        else
            POOLPCTUSED=$(df --output=pcent "/mnt/$PRIMARYSTORAGENAME" | tail -n 1 | tr -d '%')
            POOLBYTEUSED=$(df --output=used --block-size=1 "/mnt/$PRIMARYSTORAGENAME" | tail -n 1)
        fi

        # Get the size threshold in bytes
        if is_zfs_mountpoint_fstype "/mnt/$PRIMARYSTORAGENAME"; then
            POOLSIZE=$(zfs list -Hpo available,used "$PRIMARYSTORAGENAME" | awk '{print $1 + $2}')
        else
            POOLSIZE=$(df --output=size --block-size=1 "/mnt/$PRIMARYSTORAGENAME" | tail -n 1)
        fi

        # Calculate primary storage size thresholds in bytes
        if [ "$SHAREUSECACHE" = "prefer" ]; then
            # Calculate the real free space by considering an upper limit of fillup (95%) minus pool used usage for later calculations
            PRIMARYSIZETHRESH=$(((POOLSIZE - POOLBYTEUSED) * PREFER_FILLUPPCTLIMIT / 100))
            MOVESIZETHRESH=$((POOLSIZE * PREFER_MOVINGPCTTHRESHOLD / 100))
        else
            PRIMARYSIZETHRESH=$((POOLSIZE * FREEINGPCTLIMIT / 100))
            MOVESIZETHRESH=$((POOLSIZE * MOVINGPCTTHRESHOLD / 100))
        fi

        # Print pool info:
        mvlogger "Primary storage: $PRIMARYSTORAGENAME - size: $(bytes_to_human $POOLSIZE) - used: $POOLPCTUSED % ($(bytes_to_human $POOLBYTEUSED))"
        mvlogger "Secondary storage: $SECONDARYSTORAGENAME"

        # Find unattended storage for a share when rebalancing shares
        if [ "$REBALANCESHARES" = "yes" ]; then
            if [ "$PRIMARYSTORAGENAME" = "user0" ] || [ "$SECONDARYSTORAGENAME" = "user0" ]; then
                UNATTENDEDSTORAGE=$(find /mnt -type d -name "$SHARENAME" \
                    -not -path "/mnt/$PRIMARYSTORAGENAME/*" \
                    -not -path "/mnt/$SECONDARYSTORAGENAME/*" \
                    -not -path "/mnt/user*" \
                    -not -path "/mnt/disk*" \
                    -maxdepth 2 | cut -d'/' -f3 | tr '\n' ' ')
            else
                UNATTENDEDSTORAGE=$(find /mnt -type d -name "$SHARENAME" \
                    -not -path "/mnt/$PRIMARYSTORAGENAME/*" \
                    -not -path "/mnt/$SECONDARYSTORAGENAME/*" \
                    -not -path "/mnt/user*" \
                    -maxdepth 2 | cut -d'/' -f3 | tr '\n' ' ')
            fi
        fi

        if [[ "$REBALANCESHARES" == "yes" && -n "$UNATTENDEDSTORAGE" ]]; then
            mvlogger "Unattended storage: $UNATTENDEDSTORAGE"
        fi

        # Determine sharepath
        SHAREPATH="/mnt/$PRIMARYSTORAGENAME/$SHARENAME"

        if [ ! -d "$SHAREPATH" ]; then # && [ $SHAREUSECACHE != "no" ]
            # Check if share mount point is ZFS
            if is_zfs_mountpoint_fstype "/mnt/$PRIMARYSTORAGENAME"; then
                # Do not process this pool if path does not exist
                mvlogger "$SHAREPATH does not exist. Is the ZFS dataset not created yet? Copy files to '/mnt/user/$SHARENAME' first."
                mvlogger "=> Skipping"
            else
                # Do not process this pool if path does not exist
                mvlogger "$SHAREPATH does not exist. Is the share still used? Consider removing $SHARECFG if not."
                mvlogger "=> Skipping"
            fi
            continue # Move to the next iteration of the loop
        fi

        # Alterate SHAREPATH when RebalanceShare=true
        if [[ "$REBALANCESHARES" == "yes" && -n "$UNATTENDEDSTORAGE" ]]; then
            UNATTENDEDSTORAGE_SHAREPATH=""
            # Iterate over each unattended storage pool
            for dir in $UNATTENDEDSTORAGE; do
                # Skip if the share folder doesn't exist in this dir
                if [[ -d "/mnt/$dir/$SHARENAME" ]]; then
                    UNATTENDEDSTORAGE_SHAREPATH+=" \"/mnt/$dir/$SHARENAME\""
                fi
            done
        fi

        # Alterate SHAREPATH on Cache=prefer
        if [[ "$SHAREUSECACHE" == "prefer" ]]; then
            COUNT_SECONDARY_FILES=0
            PREFER_SHAREPATH=""
            PRIMARY_SHAREPATH="$SHAREPATH"

            if [[ -n "$SECONDARYSTORAGENAME" ]]; then
                # Set the share path from the secondary storage share
                SHAREPATH="/mnt/$SECONDARYSTORAGENAME/$SHARENAME"
                # Case 1: Secondary is a specific pool
                if [[ "$SECONDARYSTORAGENAME" != "user0" ]]; then
                    # Set the share path from the secondary storage share
                    SECONDARY_SHAREPATH="/mnt/$SECONDARYSTORAGENAME/$SHARENAME"
                    if [[ -d "$SECONDARY_SHAREPATH" ]]; then
                        PREFER_SHAREPATH+=" \"$SECONDARY_SHAREPATH\""
                        # Count the number of files in the secondary storage directory
                        tmp=$(find "$SECONDARY_SHAREPATH" -type f | wc -l)
                        COUNT_SECONDARY_FILES=$((COUNT_SECONDARY_FILES + tmp))
                    else
                        # Do not process this pool if path does not exist
                        mvlogger "$PRIMARY_SHAREPATH exist but $SECONDARY_SHAREPATH does not exist. Is the share on secondary storage not created yet?"
                        mvlogger "=> Skipping"
                        continue # Move to the next iteration of the loop
                    fi

                # Case 2: Secondary is the array (user0)
                else
                    for SECONDARY_SHAREPATH in /mnt/disk[0-9]/"$SHARENAME" /mnt/disk[1-9][0-9]/"$SHARENAME"; do
                        if [[ -d "$SECONDARY_SHAREPATH" ]]; then
                            # Append the path to FINDSTR, ensuring it's quoted and separated by spaces
                            PREFER_SHAREPATH+=" \"$SECONDARY_SHAREPATH\""
                            # Count the number of files in the secondary storage directory
                            tmp=$(find "$SECONDARY_SHAREPATH" -type f | wc -l)
                            COUNT_SECONDARY_FILES=$((COUNT_SECONDARY_FILES + tmp))
                        fi
                    done
                    # Check if no paths were found
                    if [[ -z "$PREFER_SHAREPATH" ]]; then
                        # Do not process this pool if path does not exist
                        mvlogger "$PRIMARY_SHAREPATH exist but no disk paths found for $SHARENAME in $SECONDARYSTORAGENAME. Is the share on secondary storage not created yet?"
                        mvlogger "=> Skipping"
                        continue # Move to the next iteration of the loop
                    fi
                fi
            fi
        fi

        if [[ "$SHAREUSECACHE" == "prefer" ]]; then
            mvlogger "Share Information: Name: $SHARENAME - Path: $PRIMARY_SHAREPATH"
        else
            mvlogger "Share Information: Name: $SHARENAME - Path: $SHAREPATH"
        fi

        # Give information according to cache mode and thresholds
        if [ "$SHAREUSECACHE" = "prefer" ]; then
            mvlogger "Moving threshold: $PREFER_MOVINGPCTTHRESHOLD% ($(bytes_to_human $MOVESIZETHRESH)) ; Filling up threshold: $PREFER_FILLUPPCTLIMIT% ($(bytes_to_human $PRIMARYSIZETHRESH))"
            if [ "$REBALANCESHARES" = "yes" ] && [ -n "$UNATTENDEDSTORAGE" ]; then
                mvlogger "Mover action: $SECONDARYSTORAGENAME->$PRIMARYSTORAGENAME (cache:prefer). Rebalance shares option is selected"
                mvlogger "=> Files detected in $UNATTENDEDSTORAGE instead of $PRIMARYSTORAGENAME or $SECONDARYSTORAGENAME. They will be rebalanced back to these."
            elif [ "$POOLPCTUSED" -lt "$PREFER_FILLUPPCTLIMIT" ]; then
                mvlogger "Mover action: $SECONDARYSTORAGENAME->$PRIMARYSTORAGENAME (cache:prefer). Pool is below priming threshold percentage: $POOLPCTUSED% < $PREFER_FILLUPPCTLIMIT%."
                mvlogger "=> Will smart move newest files from $SECONDARYSTORAGENAME to $PRIMARYSTORAGENAME until threshold."
            fi
        elif [ "$SHAREUSECACHE" = "yes" ]; then
            mvlogger "Moving threshold: $MOVINGPCTTHRESHOLD% ($(bytes_to_human $MOVESIZETHRESH)) ; Freeing threshold: $FREEINGPCTLIMIT% ($(bytes_to_human $PRIMARYSIZETHRESH))"
            if [ "$REBALANCESHARES" = "yes" ] && [ -n "$UNATTENDEDSTORAGE" ]; then
                mvlogger "Mover action: $PRIMARYSTORAGENAME->$SECONDARYSTORAGENAME (cache:yes). Rebalance shares option is selected"
                mvlogger "=> Files detected in $UNATTENDEDSTORAGE instead of $PRIMARYSTORAGENAME or $SECONDARYSTORAGENAME. They will be rebalanced to $SECONDARYSTORAGENAME."
            elif [ "$OMOVERTHRESH" != "" ] && [ "$POOLPCTUSED" -gt "$OMOVERTHRESH" ]; then
                mvlogger "Mover action: $PRIMARYSTORAGENAME->$SECONDARYSTORAGENAME (cache:yes). Move All from Primary->Secondary shares option is selected and pool is above move all threshold percentage:  $POOLPCTUSED% > $OMOVERTHRESH%."
                mvlogger "=> Moving all files from $PRIMARYSTORAGENAME to $SECONDARYSTORAGENAME"
            elif [ "$POOLPCTUSED" -lt "$MOVINGPCTTHRESHOLD" ]; then
                mvlogger "Mover action: $PRIMARYSTORAGENAME->$SECONDARYSTORAGENAME (cache:yes). Pool is below moving threshold percentage: $POOLPCTUSED% < $MOVINGPCTTHRESHOLD%."
                if [ "$SYNCHRONIZECACHE" = "yes" ] || [ "$RESYNCHRONIZECACHE" = "yes" ]; then
                    mvlogger "=> No file will be moved but share processed as Synchronize Primary->Secondary option is set"
                else
                    mvlogger "=> Skipping"
                    continue
                fi
            else
                mvlogger "Mover action: $PRIMARYSTORAGENAME->$SECONDARYSTORAGENAME (cache:yes). Pool is above moving threshold percentage:  $POOLPCTUSED% >= $MOVINGPCTTHRESHOLD%."
                mvlogger "=> Will smart move old files from $PRIMARYSTORAGENAME to $SECONDARYSTORAGENAME. Nothing will be moved from $SECONDARYSTORAGENAME to $PRIMARYSTORAGENAME"
            fi
        elif [ "$SHAREUSECACHE" = "only" ]; then
            if [ "$REBALANCESHARES" = "yes" ] && [ -n "$UNATTENDEDSTORAGE" ]; then
                mvlogger "Mover action: no action, only $PRIMARYSTORAGENAME used (cache:only). Rebalance shares option is selected"
                mvlogger "=> Files detected in $UNATTENDEDSTORAGE instead of $PRIMARYSTORAGENAME. They will be rebalanced to $PRIMARYSTORAGENAME"
            else
                # Check if there's only one share in the cache pool
                ONLY_ONE_SHARE=$(find "/mnt/$PRIMARYSTORAGENAME" -maxdepth 1 -type d -not -path "/mnt/$PRIMARYSTORAGENAME" | wc -l)
                if [ "$ONLY_ONE_SHARE" -eq 1 ]; then
                    mvlogger "Mover action: no action, only $PRIMARYSTORAGENAME used (cache:only)."
                    mvlogger "Only one share found in cache pool. Skipping cache pool size calculation."
                else
                    mvlogger "Mover action: no action, only $PRIMARYSTORAGENAME used (cache:only)."
                    mvlogger "=> Nothing will be moved. Share usage is taken into account in the calculation of the threshold for other shares."
                    if is_zfs_mountpoint_fstype "/mnt/$PRIMARYSTORAGENAME"; then
                        mvlogger "Calculating zfs share usage..."
                        CACHESHARERESERVEDSPACE=$(zfs list -Hpo used "$PRIMARYSTORAGENAME/$SHARENAME")
                        # if error on command then share can be a folder instead dataset
                        if [ $? -ne 0 ]; then
                            mvlogger "Warning: Share is currently a folder. Convert it to a dataset for better performance."
                            mvlogger "Calculating share usage... (can take a moment)"
                            CACHESHARERESERVEDSPACE=$(du -sh "$SHAREPATH" | awk '{print $1}' | human_to_bytes)
                        fi
                    else
                        mvlogger "Calculating share usage... (can take a moment)"
                        CACHESHARERESERVEDSPACE=$(du -sh "$SHAREPATH" | awk '{print $1}' | human_to_bytes)
                    fi
                fi
                echo "$PRIMARYSTORAGENAME|$SECONDARYSTORAGENAME|$SHARENAME|only|9999999999|$PRIMARYSIZETHRESH|$CACHESHARERESERVEDSPACE|0|0|0|${SHAREPATH}" >>"$FILTERED_FILELIST"
                mvlogger "$PRIMARYSTORAGENAME/$SHARENAME used: $(bytes_to_human "$CACHESHARERESERVEDSPACE")"
                continue
            fi
        elif [ "$SHAREUSECACHE" = "no" ]; then
            if [ "$REBALANCESHARES" = "yes" ] && [ -n "$UNATTENDEDSTORAGE" ]; then
                mvlogger "Mover action: no action, only $PRIMARYSTORAGENAME used (cache:no). Rebalance shares option is selected"
                mvlogger "=> Files detected in $UNATTENDEDSTORAGE instead of $PRIMARYSTORAGENAME. They will be rebalanced to $PRIMARYSTORAGENAME"
            else
                mvlogger "Mover action: no action, only $PRIMARYSTORAGENAME used (cache:no)."
                mvlogger "=> Skipping"
                continue
            fi
        fi

        # Do not process this pool if Share path is /mnt/cache
        if [[ "$SHAREPATH" == "/mnt/cache" ]]; then
            mvlogger "Skipping processing for /mnt/cache"
            continue # Move to the next iteration of the loop
        fi

        # Initialize FINDSTR with the base find command
        FINDSTR="find"
        # Alterate SHAREPATH when RebalanceShare=true
        if [[ "$REBALANCESHARES" == "yes" && -n "$UNATTENDEDSTORAGE" ]]; then
            FINDSTR+=" ${UNATTENDEDSTORAGE_SHAREPATH}"
        fi

        # Alter SHAREPATH on Cache=prefer
        if [[ "$SHAREUSECACHE" == "prefer" ]]; then
            FINDSTR+=" $PREFER_SHAREPATH"
        # Alter SHAREPATH on Cache=yes
        elif [[ "$SHAREUSECACHE" == "yes" ]]; then
            FINDSTR+=" \"${SHAREPATH}\""
        fi

        # Add a search files option for the shares at the end
        FINDSTR+=" -type f"

        #Addition of filters are conditionned by [ -z "$OMOVERTHRESH" ] || [ $POOLPCTUSED -le $OMOVERTHRESH ] to prevent filtering move all Primary->Secondary share
        # Add Age variables to find string
        if { [ -z "$OMOVERTHRESH" ] || [ "$POOLPCTUSED" -le "$OMOVERTHRESH" ]; } && [ "$AGE" -ge 1 ]; then
            mvlogger "Adding Age"
            RAGE=$((AGE - 1))
            # Use Creation time or modification time according to settings
            if [ "$CTIME" == "yes" ]; then
                mvlogger "Age (creation time) ${AGE}"
                FINDSTR="${FINDSTR} -ctime +${RAGE}"
            elif [ "$ATIME" == "yes" ]; then
                mvlogger "Age (access time) ${AGE}"
                FINDSTR="${FINDSTR} -atime +${RAGE}"
            else
                mvlogger "Age (modification time) ${AGE}"
                FINDSTR="${FINDSTR} -mtime +${RAGE}"
            fi
        fi

        # Add Size to find string
        if [ -z "$OMOVERTHRESH" ] || [ "$POOLPCTUSED" -le "$OMOVERTHRESH" ]; then
            if [[ "$SYNCHRONIZECACHE" = "yes" ]] || [[ "$RESYNCHRONIZECACHE" = "yes" ]] && [[ "$POOLPCTUSED" -lt "$MOVINGPCTTHRESHOLD" ]] && [ "$SYNC_SIZE" -gt 0 ]; then
                mvlogger "Adding Sync Size: ${SYNC_SIZE}"
                FINDSTR="$FINDSTR -size -${SYNC_SIZE}M"
            elif [ "$SIZE" -gt 0 ]; then
                mvlogger "Adding Move Size: ${SIZE}"
                FINDSTR="$FINDSTR -size +${SIZE}M"
            fi
        fi

        # Add Ignore Hidden Files to find string
        if { [ -z "$OMOVERTHRESH" ] || [ "$POOLPCTUSED" -le "$OMOVERTHRESH" ]; } && { [ "$SHAREUSECACHE" = "prefer" ] || [ "$SHAREUSECACHE" = "yes" ]; } && [ "$IGNOREHIDDENFILES" == "yes" ]; then
            mvlogger "Skipping Hidden Files. File size are taken into account in the calculation of the threshold"
            FINDSTR="$FINDSTR -not -path '*/\.*'"
            HIDDENFILES_RESERVED_SPACE=$(find "/mnt/$PRIMARYSTORAGENAME/$SHARENAME" -type f -name '.*' -print0 | du -ch --files0-from=- | awk '/total$/ {print $1}' | human_to_bytes)
            echo "$PRIMARYSTORAGENAME|$SECONDARYSTORAGENAME|$SHARENAME|skipped|9999999999|$PRIMARYSIZETHRESH|$HIDDENFILES_RESERVED_SPACE|0|0|0|${SHAREPATH}/ hidden files" >>"$FILTERED_FILELIST"
            mvlogger "    Hidden files are using $(bytes_to_human "$HIDDENFILES_RESERVED_SPACE")"
        fi

        # Add skipped files and folders
        FINDSTR="$FINDSTR -not -name '.placeholder'" #do not move placeholders

        # Add files from ignore list
        if { [ -z "$OMOVERTHRESH" ] || [ "$POOLPCTUSED" -le "$OMOVERTHRESH" ]; } && { [ "$SHAREUSECACHE" = "prefer" ] || [ "$SHAREUSECACHE" = "yes" ]; } && [ -f "$SKIPFILESLIST" ] && grep -q "/mnt/${PRIMARYSTORAGENAME}/${SHARENAME}" "$SKIPFILESLIST"; then
            mvlogger "Skipping Files from List. File size are taken into account in the calculation of the threshold"
            mvlogger "List Path: ${SKIPFILESLIST}:"

            # Fix CRLF in skip list file
            if grep -q $'\r' "${SKIPFILESLIST}"; then
                mvlogger "Warning: Windows-style CRLF line endings detected in ${SKIPFILESLIST}. Converting to LF..."
                mvDebuglogger "Detected Windows CRLF endings in skip file ${SKIPFILESLIST}. Converting to LF..." "Prepare Skipped Path"
                sed -i 's/\r$//' "${SKIPFILESLIST}"
            fi

            TOTAL_SKIPPED_PATH_RESERVED_SPACE=0
            while IFS= read -r skipped_path; do
                SKIPPED_PATH_RESERVED_SPACE=""
                # Remove potential trailing /, *, /* characters from the skipped_path
                skipped_path="${skipped_path%"${skipped_path##*[!/*]}"}"
                #skipped_path="${skipped_path%/}" # Remove potential trailing slash
                mvDebuglogger "skipped_path = $skipped_path" "Skipped Path"
                if [[ -d "${skipped_path}" || -f "${skipped_path}" ]]; then
                    mvDebuglogger "${skipped_path} - exists" "Skipped Path"
                    SKIPPED_PATH_RESERVED_SPACE="$(du -sh "${skipped_path}" | awk '{print $1}' | human_to_bytes)"

                    if [[ -d "${skipped_path}" ]]; then
                        mvDebuglogger "${skipped_path} - is a Folder" "Skipped Path"
                        # Add /* at the end for better reading in Mover_action file
                        skipped_path="${skipped_path}/*"
                    elif [[ -f "${skipped_path}" ]]; then
                        mvDebuglogger "${skipped_path} - is a File" "Skipped Path"
                    fi

                    FINDSTR="$FINDSTR -not -path \"${skipped_path//[/\\[}\"" # fixed when folder contain '['
                else
                    mvDebuglogger "${skipped_path} - does not exist?" "Skipped Path"
                    continue
                fi

                if [ -n "$SKIPPED_PATH_RESERVED_SPACE" ]; then
                    echo "$PRIMARYSTORAGENAME|$SECONDARYSTORAGENAME|$SHARENAME|skipped|9999999999|$PRIMARYSIZETHRESH|$SKIPPED_PATH_RESERVED_SPACE|0|0|0|${skipped_path}" >>"$FILTERED_FILELIST"
                    TOTAL_SKIPPED_PATH_RESERVED_SPACE=$((TOTAL_SKIPPED_PATH_RESERVED_SPACE + SKIPPED_PATH_RESERVED_SPACE))
                else
                    mvlogger "Error calculating size for $skipped_path"
                fi
            done <<<"$(grep "/mnt/${PRIMARYSTORAGENAME}/${SHARENAME}" "${SKIPFILESLIST}")"
            mvlogger "    Ignored files are using $(bytes_to_human $TOTAL_SKIPPED_PATH_RESERVED_SPACE)"
        fi

        #Add Skipfilelist to find string
        TOTAL_SKIPPED_FILETYPES_RESERVED_SPACE=0
        if { [ -z "$OMOVERTHRESH" ] || [ "$POOLPCTUSED" -le "$OMOVERTHRESH" ]; } && { [ "$SHAREUSECACHE" = "prefer" ] || [ "$SHAREUSECACHE" = "yes" ]; } && { [ -n "$SKIPFILETYPES" ] || [ -n "$globalSkipFileTypes" ]; }; then
            mvlogger "Skipping Filetypes from List. File sizes are taken into account for the calculation of the threshold"
            for ext in $([ $overrideFlag = 1 ] && echo -n "$SKIPFILETYPES") $(echo -n "$globalSkipFileTypes"); do
                FINDSTR="$FINDSTR -not -name '*.$ext'"
                SKIPPED_FILETYPES_RESERVED_SPACE="$(find "/mnt/${PRIMARYSTORAGENAME}/${SHARENAME}" -type f -name '*.$ext' -print0 | xargs -0 du -sh | awk '{print $1}' | human_to_bytes | awk '{ sum += $1 } END { print sum }')"
                if [ $? -eq 0 ]; then
                    echo "$PRIMARYSTORAGENAME|$SECONDARYSTORAGENAME|$SHARENAME|skipped|9999999999|$PRIMARYSIZETHRESH|$SKIPPED_FILETYPES_RESERVED_SPACE|0|0|0|$SHAREPATH/**/*.$ext" >>"$FILTERED_FILELIST"
                    TOTAL_SKIPPED_FILETYPES_RESERVED_SPACE=$((TOTAL_SKIPPED_FILETYPES_RESERVED_SPACE + SKIPPED_FILETYPES_RESERVED_SPACE))
                else
                    mvlogger "Error calculating size for ${globalSkipFileTypes}"
                fi
            done
            mvlogger "    Ignored filetypes are using $(bytes_to_human $TOTAL_SKIPPED_FILETYPES_RESERVED_SPACE)"
        fi

        #Add Size to find string and pass to awk to modify some fields
        #FINDSTR+=" -printf '%T@|%s|%S|%n|%i|%p|\0' | awk -v RS='\0' -v FS='|' -v SPARSENESS=\$SPARSENESS -v PRIMARYSTORAGENAME=\$PRIMARYSTORAGENAME -v SECONDARYSTORAGENAME=\$SECONDARYSTORAGENAME -v SHARENAME=\$SHARENAME -v SHAREUSECACHE=\$SHAREUSECACHE -v PRIMARYSIZETHRESH=\$PRIMARYSIZETHRESH"
        # Fix shares space issue but same code as above
        FINDSTR="$FINDSTR -printf '%T@|%s|%S|%n|%i|%p|\0'"
        FINDSTR="$FINDSTR | awk -v RS='\0' -v FS='|' \
        -v SPARSENESS='$SPARSENESS' \
        -v PRIMARYSTORAGENAME='$PRIMARYSTORAGENAME' \
        -v SECONDARYSTORAGENAME='$SECONDARYSTORAGENAME' \
        -v SHARENAME='$SHARENAME' \
        -v SHAREUSECACHE='$SHAREUSECACHE' \
        -v PRIMARYSIZETHRESH='$PRIMARYSIZETHRESH'"

        if { [ -z "$OMOVERTHRESH" ] || [ "$POOLPCTUSED" -le "$OMOVERTHRESH" ]; } && [ "$SPARSENESS" -gt 0 ]; then
            mvlogger "Adding Sparseness size ${SPARSENESS}"
            FINDSTR="$FINDSTR ' \$3 > 0.SPARSENESS ' {"
        else
            FINDSTR="$FINDSTR ' {"
        fi
        # Get Birthtime with stat if CTIME option enabled
        if [ $CTIME == "yes" ]; then
            FINDSTR="$FINDSTR cmd=\"stat -c%W \\\"\"\$6\"\\\"\";
                cmd | getline result;
                close(cmd);
                sub(/\\n\$/, \"\", result);
                \$1 = result;
            "
        fi

        # Get Birthtime with stat if ATIME option enabled
        if [ $ATIME == "yes" ]; then
            FINDSTR="$FINDSTR cmd=\"stat -c%X \\\"\"\$6\"\\\"\";
                cmd | getline result;
                close(cmd);
                sub(/\\n\$/, \"\", result);
                \$1 = result;
            "
        fi

        # Get size with du if on zfs mountpoint with compression enabled
        #        if is_zfs_mountpoint_fstype "/mnt/$PRIMARYSTORAGENAME" && [ "$(zfs get compression -Hpo value "$PRIMARYSTORAGENAME/$SHARENAME")" == "on" ]; then
        #            FINDSTR="$FINDSTR cmd = \"du -sh \\\"\"\$6\"\\\" | numfmt --from=iec\";
        #                cmd | getline result;
        #                close(cmd);
        #                sub(/\\n\$/, \"\", result);
        #                \$2 = result;
        #            "
        #        fi
        FINDSTR="$FINDSTR printf \"%s|%s|%s|%s|%d|%d|%d|%d|%d|%d|%s\\n\", PRIMARYSTORAGENAME, SECONDARYSTORAGENAME, SHARENAME, SHAREUSECACHE, \$1, PRIMARYSIZETHRESH, \$2, \$3, \$4, \$5, \$6}'"

        # Send FINDSTR to debug
        mvDebuglogger "FINDSTR: $FINDSTR" "[$SHARENAME] share Find Function"

        # cache:prefer counted files to move from secondary storage for print next if commands only if secondary storage is not empty
        if [ "$SHAREUSECACHE" = "prefer" ]; then
            mvDebuglogger "Amount of files on secondary storage: $COUNT_SECONDARY_FILES" "[$SHARENAME] count files"
        fi

        if [ -d "$SHAREPATH" ] || [[ "$SHAREUSECACHE" = "prefer" && "$COUNT_SECONDARY_FILES" -gt 0 ]] || [ "$REBALANCESHARES" = "yes" ]; then
            [ "$CTIME" == "yes" ] && mvlogger "Filtering $SHARENAME files... (can take a moment)"
            eval "${FINDSTR}>>${FILTERED_FILELIST}"
            mvlogger "Updated Filtered filelist: $FILTERED_FILELIST for $SHARENAME"
        fi
    done

    # Sort the file list by PRIMARYSTORAGENAME, shareusecache, creation/modification time, and inode, keeping /mnt/disk at the end
    sort -t '|' -k1,1 -k4,4 -k5,5nr -k10,10 -o "$FILTERED_FILELIST" "$FILTERED_FILELIST"
    # Need to remove duplicate (cache and array)
    if grep -q "/mnt/disk" "$FILTERED_FILELIST"; then
        mvlogger "$(titleLine 'Optimizing Filtered Filelist' '-')"
        tempfile1=$(mktemp)
        tempfile2=$(mktemp)

        mvlogger "Removing duplicate giving priority to cache"
        grep -v "/mnt/disk" "$FILTERED_FILELIST" >"$tempfile1"
        grep "/mnt/disk" "$FILTERED_FILELIST" >"$tempfile2"
        cat "$tempfile1" "$tempfile2" | awk -F"|" '
            function is_duplicate(key) {
                if (prev[key]) {
                    return true
                } else {
                    prev[key] = 1
                    return false
                }
            }
            function extract_path(filepath) {
                # Optimized path extraction using sub
                sub(/^\/[^\/]+\/[^\/]+\/[^\/]+\//, "", filepath)
                return filepath
            }
            BEGIN {
                FS = OFS = "|"

                if (system("[ -e \"" SOFTSTOPFILE "\" ]") == 0) {
                    exit 1
                }
                # Initialize previous inode and dictionary for pool sums
                previous_inode = 0

                # Print new header
                printf "PRIMARYSTORAGENAME|SECONDARYSTORAGENAME|SHARENAME|SHAREUSECACHE|MODIFICATIONTIME|PRIMARYSIZETHRESH|FILESIZE|SPARSENESS|NBLINKS|INODE|FILEPATH\n"
            }

            NR > 1 { # Main loop, skip header line
                if (system("[ -e \"" SOFTSTOPFILE "\" ]") == 0) {
                    exit 1
                }
                file_path = extract_path($11)

                # Handle duplicates
                key = $3 "|" $5 "|" $7 "|" file_path
                if (! is_duplicate(key)) {
                    printf "%s|%s|%s|%s|%d|%d|%d|%d|%d|%d|%s\n", $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
                }
            }' >"$FILTERED_FILELIST"
        mvlogger "Sorting"
        sort -t '|' -k1,1 -k4,4 -k5,5nr -k10,10 -o "$FILTERED_FILELIST" "$FILTERED_FILELIST"
        rm "$tempfile1" "$tempfile2"
    fi
}

decideMoveActions() {
    if [ -e $SOFTSTOPFILE ]; then
        [ $SOFTSTOP_ACK = true ] || mvlogger "Soft Stopping requested" && SOFTSTOP_ACK=true
        return
    fi

    # Title line
    mvlogger "$(titleLine 'ANALYSING MOVING ACTIONS' '*')"

    #If overrideFLag set restore settings
    if [ $overrideFlag = 1 ]; then
        overrideFlag=0
        #Get Mover Tuning Settings
        mvlogger "Restore global settings"
        mvlogger "-----------------------"
        getMoverSettings "$MOVERTUNINGCFGFILE"
        mvlogger "------------------------------------------------------------------------"
    fi

    ## Loop Filtered Filelist and for each file decide to move to/from the array
    mvlogger "Deciding the action (move/sync/keep) for each file. There are $(grep -c "/mnt" "$FILTERED_FILELIST") files, it can take a while..."

    ## Proceed with files
    # Fields: $1:PRIMARYSTORAGENAME $2:SECONDARYSTORAGENAME $3:SHARENAME $4:SHAREUSECACHE $5:MODIFICATIONTIME
    # $6:PRIMARYSIZETHRESH $7:FILESIZE $8:SPARSENESS $9:NBLINKS $10:INODE $11:FILEPATH

    awk -F"|" -v AGE="$AGE" -v STATS_FILE="$STATS_FILE" -v LASTCACHESYNC="$LASTCACHESYNC" -v SOFTSTOPFILE="$SOFTSTOPFILE" -v MOVERTUNING_OVERRIDE_CFGFOLDER="$MOVERTUNING_OVERRIDE_CFGFOLDER" -v SYNCHRONIZECACHE="$SYNCHRONIZECACHE" -v REBALANCESHARES="$REBALANCESHARES" -v RESYNCHRONIZECACHE="$RESYNCHRONIZECACHE" '
        BEGIN {
            FS = OFS = "|"

            if (system("[ -e \"" SOFTSTOPFILE "\" ]") == 0) {
                exit 1
            }
            # Initialize previous inode and dictionary for pool sums
            previous_inode = 0

            # Init variables for track last share for Sync overrides
            prev_share = ""
            global_sync = SYNCHRONIZECACHE

            # Check if MOVERTUNING_OVERRIDE_CFGFOLDER exists
            shareOverrideCfgDir_exist = (system("test -d \"" MOVERTUNING_OVERRIDE_CFGFOLDER "\"") == 0)

            # Print new header
            printf "PRIMARYSTORAGENAME|SHARENAME|SHAREUSECACHE|MODIFICATIONTIME|FILESIZE|POOLSUM|THRESHOLD|NBLINKS|INODE|ACTION|FROM|TO|FILEPATH\n"
        }

        NR > 1 { # Main loop, skip header line
            if (system("[ -e \"" SOFTSTOPFILE "\" ]") == 0) {
                exit 1
            }

            # Extract the part after the first three slashes (/mnt/pool/) in the eleventh field (filepath)
            split($11, path_parts, "/")
            storage_path = path_parts[1] "/" path_parts[2] "/" path_parts[3]
            storage_pool = path_parts[3]
            file_path = ""
            for (i = 4; i <= length(path_parts); i++) {
                file_path = file_path path_parts[i]
                if (i < length(path_parts)) {
                    file_path = file_path "/"
                }
            }

            # Handle hardlinks
            if ($9 > 1) {
                key = $1 "|" $2 "|" $3 "|" $10
                if (prev[key]) {
                    $7 = 0
                } else {
                    prev[key] = 1
                }
            }

            # Update pool sum (use pool_sums[$1])
            pool_sums[$1] += $7

            ### Check if share has Sync override ###
            # Set current sharename
            sharename = $3
            
            # Check at the start using previous state
            if (shareOverrideCfgDir_exist && global_sync == "no" && sharename != prev_share) {

            # Initialize for this share
            cfgfile = MOVERTUNING_OVERRIDE_CFGFOLDER "/" sharename ".cfg"
            SYNCHRONIZECACHE = "no"
            LASTCACHESYNC = ""
            moverOverride = 0
            synchronizeCache = 0

            # Check file exists
            if ((getline test < cfgfile) > 0) {
                close(cfgfile)

                # parse the file
                while ((getline line < cfgfile) > 0) {
                    if (line ~ /moverOverride="yes"/)
                        moverOverride = 1
                    if (line ~ /synchronizeCache="yes"/)
                        synchronizeCache = 1
                    if (match(line, /lastCacheSync="([^"]+)"/, m))
                        LASTCACHESYNC = m[1]
                }
                close(cfgfile)

                if (moverOverride && synchronizeCache) {
                    SYNCHRONIZECACHE = "yes"
                }
            }

            # remember current state for next record
            prev_share = sharename
            }
            ### ###

            # Take decision
            if (storage_pool == $1) {
                # Make decision to move or keep:
                action = (($4 != "only" && $4 != "skipped" && $4 != "prefer") && ($4 == "yes" && (pool_sums[$1] >= $6 && (AGE == -1 || AGE >= 0)))) ? "move from primary" : "keep on primary"

                if (action == "keep on primary")  {
                    source = storage_path
                    if (SYNCHRONIZECACHE == "yes" && ($4 != "only" && $4 != "skipped" && $4 != "prefer") && ($5 >= LASTCACHESYNC || RESYNCHRONIZECACHE == "yes"))  {
                        action = "sync from primary"
                        destination = "/mnt/" $2
                        pool_stats[$1]["files_from_primary"] += 1
                        pool_stats[$1]["total_size_from_primary"] += $7
                    } else {
                        destination = "none"
                    }
                }

                # Update pool statistics and set destination if moving the file
                if (action == "move from primary") {
                    source = storage_path
                    destination = "/mnt/" $2
                    pool_stats[$1]["files_from_primary"] += 1
                    pool_stats[$1]["total_size_from_primary"] += $7
                }
            } else {
                if (storage_pool == "user" || ($2 == "user0" && storage_pool ~ "disk")) {
                    # Make decision to move or keep:
                    action = (($4 == "only" && REBALANCESHARES == "yes") || ($4 == "prefer" && pool_sums[$1] <= $6 && (AGE == -1 || AGE >= 0))) ? "move from secondary" : "keep on secondary"

                    if (action == "keep on secondary") {
                        source = storage_path
                        destination = "none"
                    }

                    # Update pool statistics and set destination if moving the file
                    if (action == "move from secondary") {
                        source = storage_path
                        destination = "/mnt/" $1
                        if (SYNCHRONIZECACHE == "yes" && ($4 != "only" && $4 != "skipped"))  {
                            action = "sync from secondary"
                        }
                        pool_stats[$1]["files_from_secondary"] += 1
                        pool_stats[$1]["total_size_from_secondary"] += $7
                    }
                } else {
                    if (REBALANCESHARES == "yes") {
                        action = ($4 == "only" || ($4 == "prefer" && pool_sums[$1] <= $6)) ? "move unattended to primary" : "move unattended to secondary"
                        if (action == "move unattended to primary" && SYNCHRONIZECACHE == "yes" && $4 != "only" )  {
                            source = storage_path
                            destination = "/mnt/" $1
                            pool_stats[$1]["files_from_unattended"] += 1
                            pool_stats[$1]["total_size_from_unattended"] += $7
                            # Add a line in mover_action as intermediary step
                            printf "%s|%s|%s|%d|%d|%d|%d|%d|%s|%s|%s|%s|%s\n", $1, $3, $4, $5, $7, pool_sums[$1], $6, $9, $10, action, source, destination, file_path
                            action="sync unattended to secondary"
                            source = "/mnt/" $1
                            destination = "/mnt/" $2
                        } else {
                            if (action == "move unattended to primary") {
                                source = storage_path
                                destination = "/mnt/" $1
                            } else {
                                action = "move unattended to secondary"
                                source = storage_path
                                destination = "/mnt/" $2
                            }
                        }
                        pool_stats[$1]["files_from_unattended"] += 1
                        pool_stats[$1]["total_size_from_unattended"] += $7
                    } else {
                        action="keep misplaced" #If not on primary nor secondary, file will be tagged misplaced                
                        source = storage_path
                        destination = "none"
                    }
                }
            }

            # Create action list
            printf "%s|%s|%s|%d|%d|%d|%d|%d|%s|%s|%s|%s|%s\n", $1, $3, $4, $5, $7, pool_sums[$1], $6, $9, $10, action, source, destination, file_path
        }
        END {
            if (system("[ -e \"" SOFTSTOPFILE "\" ]") == 0) {
                exit 1
            }

            # Write statistics header line
            printf "PRIMARYSTORAGENAME|FILES_FROM_PRIMARY|SIZE_FROM_PRIMARY|FILES_FROM_SECONDARY|SIZE_FROM_SECONDARY|FILES_FROM_UNATTENDED|SIZE_FROM_UNATTENDED\n" > "'"${STATS_FILE}"'"

            # Loop through pool_stats and write data to stats_file
            total_files_from_primary = 0
            total_size_from_primary = 0
            total_files_from_secondary = 0
            total_size_from_secondary = 0
            total_files_from_unattended = 0
            total_size_from_unattended = 0

            for (poolname in pool_stats) {
                files_from_primary = pool_stats[poolname]["files_from_primary"]
                size_from_primary = pool_stats[poolname]["total_size_from_primary"]
                files_from_secondary = pool_stats[poolname]["files_from_secondary"]
                size_from_secondary = pool_stats[poolname]["total_size_from_secondary"]
                files_from_unattended = pool_stats[poolname]["files_from_unattended"]
                size_from_unattended = pool_stats[poolname]["total_size_from_unattended"]

                total_files_from_primary += files_from_primary
                total_files_from_secondary += files_from_secondary
                total_size_from_primary += size_from_primary
                total_size_from_secondary += size_from_secondary
                total_files_from_unattended += files_from_unattended
                total_size_from_unattended += size_from_unattended
                printf("%s|%d|%d|%d|%d|%d|%d\n", poolname, files_from_primary, size_from_primary, files_from_secondary, size_from_secondary, files_from_unattended, size_from_unattended) >> "'"${STATS_FILE}"'"
            }

            # Print overall totals to stats file
            printf("TOTAL|%d|%d|%d|%d|%d|%d\n", total_files_from_primary, total_size_from_primary, total_files_from_secondary, total_size_from_secondary, total_files_from_unattended, total_size_from_unattended) >> "'"${STATS_FILE}"'"

    }' "$FILTERED_FILELIST" >"$MOVER_ACTIONLIST"
    if [ -e $SOFTSTOPFILE ]; then
        [ $SOFTSTOP_ACK = true ] || mvlogger "Soft Stopping requested" && SOFTSTOP_ACK=true
        return
    fi

    ## Printing some stats
    TOTALPRIMARYFILES=$(grep "TOTAL" "$STATS_FILE" | cut -d "|" -f 2)
    TOTALPRIMARYSIZE=$(grep "TOTAL" "$STATS_FILE" | cut -d "|" -f 3)
    TOTALSECONDARYFILES=$(grep "TOTAL" "$STATS_FILE" | cut -d "|" -f 4)
    TOTALSECONDARYSIZE=$(grep "TOTAL" "$STATS_FILE" | cut -d "|" -f 5)
    TOTALUNATTENDEDFILES=$(grep "TOTAL" "$STATS_FILE" | cut -d "|" -f 6)
    TOTALUNATTENDEDSIZE=$(grep "TOTAL" "$STATS_FILE" | cut -d "|" -f 7)

    # Add total files and size
    TOTALFILES=$((TOTALPRIMARYFILES + TOTALSECONDARYFILES + TOTALUNATTENDEDFILES))
    TOTALSIZE=$((TOTALPRIMARYSIZE + TOTALSECONDARYSIZE + TOTALUNATTENDEDSIZE))
    UNATTENDEDFILES=$(grep -c "keep misplaced" "$MOVER_ACTIONLIST")

    # Print stats
    if [ "$UNATTENDEDFILES" -gt 0 ]; then
        mvlogger "Warning: $UNATTENDEDFILES files are stored outside their primary or secondary storages and won't be moved according to actual settings."
    fi
    if [ $TOTALFILES -gt 0 ]; then
        mvlogger "A total of $TOTALFILES files representing $(bytes_to_human $TOTALSIZE) will be moved/synced:"
        if [ "$TOTALPRIMARYFILES" -gt 0 ]; then
            # Read data line by line using while loop
            while IFS="|" read -r PRIMARYSTORAGENAME PRIMARYFILES PRIMARYSIZE SECONDARYFILES SECONDARYSIZE; do
                if [ -e $SOFTSTOPFILE ]; then
                    [ $SOFTSTOP_ACK = true ] || mvlogger "Soft Stopping requested" && SOFTSTOP_ACK=true
                    break
                fi
                # Check if line is not the total line nor the header line
                if [ "$PRIMARYSTORAGENAME" != "TOTAL" ] && [ "$PRIMARYSTORAGENAME" != "PRIMARYSTORAGENAME" ]; then
                    mvlogger "- $PRIMARYFILES files representing $(bytes_to_human $PRIMARYSIZE) will be moved/sync from $PRIMARYSTORAGENAME to secondary"
                fi
            done <"$STATS_FILE"
        fi
        if [ "$TOTALSECONDARYFILES" -gt 0 ]; then
            mvlogger "- $TOTALSECONDARYFILES new files representing $(bytes_to_human $TOTALSECONDARYSIZE) will then be moved/synced from secondary to primary"
        fi
        if [ "$TOTALUNATTENDEDFILES" -gt 0 ]; then
            mvlogger "- $TOTALUNATTENDEDFILES files from unattended storage and representing $(bytes_to_human $TOTALUNATTENDEDSIZE) will then be rebalanced from unattended shares to primary and/or secondary"
        fi
    else
        mvlogger "No new files will be moved/synced from primary to secondary"
        mvlogger "No new files will be moved/synced from secondary to primary"
    fi
}

# Internal move engine
processTheMoves() {
    if [ -e $SOFTSTOPFILE ]; then
        [ $SOFTSTOP_ACK = true ] || mvlogger "Soft Stopping requested" && SOFTSTOP_ACK=true
        return
    fi

    mvlogger "$(titleLine 'LET THE MOVING SHOW BEGIN !' '*')"
    if [ "$ENABLETURBO" = "yes" ]; then
        mvlogger "Forcing turbo write on"
        [ "$TESTMODE" != "yes" ] && /usr/local/sbin/mdcmd set md_write_method 1
    fi
    # MOVER_ACTIONLIST header:
    # PRIMARYSTORAGENAME|SHARENAME|SHAREUSECACHE|MODIFICATIONTIME|FILESIZE|POOLSUM|THRESHOLD|NBLINKS|INODE|ACTION|FROM|TO|FILEPATH

    #Initialise stats:
    REMAINING_ARRAY_SIZE=$TOTALSECONDARYSIZE
    REMAINING_ARRAY_FILES=$TOTALSECONDARYFILES
    REMAINING_CACHE_SIZE=$TOTALPRIMARYSIZE
    REMAINING_CACHE_FILES=$TOTALPRIMARYFILES
    REMAINING_UNATTENDED_SIZE=$TOTALUNATTENDEDSIZE
    REMAINING_UNATTENDED_FILES=$TOTALUNATTENDEDFILES

    # Dry mode info:
    if [ $TESTMODE = "yes" ]; then
        mvlogger "Warning: Test Mode: yes, running $MOVE_FILES_TOOL in dry-mode for moving $([ "$MOVE_FILES_TOOL" = "rsync" ] && echo 'and syncing')"
    fi

    # Loop through each line in the action list (except those where action is keep), starting by cache and then array
    GREP_CMDS=(
        "grep '|move from primary|' '$MOVER_ACTIONLIST'"
        "grep '|move unattended to secondary|' '$MOVER_ACTIONLIST'"
        "grep '|sync from primary|' '$MOVER_ACTIONLIST'"
        "grep '|move from secondary|' '$MOVER_ACTIONLIST'"
        "grep '|sync from secondary|' '$MOVER_ACTIONLIST'"
        "grep '|move unattended to primary|' '$MOVER_ACTIONLIST'"
        "grep '|sync unattended to secondary|' '$MOVER_ACTIONLIST'"
    )
    # Ignore "grep '|keep on primary|' '$MOVER_ACTIONLIST'" action because it's not an action

    for GREP_CMD in "${GREP_CMDS[@]}"; do
        while IFS="|" read -r PRIMARYSTORAGENAME SHARENAME SHAREUSECACHE MODIFICATIONTIME FILESIZE POOLSUM THRESHOLD NBLINKS INODE ACTION SOURCE DESTINATION FILEPATH; do
            if [ -e $SOFTSTOPFILE ]; then
                [ $SOFTSTOP_ACK = true ] || mvlogger "Soft Stopping requested" && SOFTSTOP_ACK=true
                return
            fi

            # Skip if ~blank~ line
            if [ -z "$NBLINKS" ] || [ -z "$FILESIZE" ] || [ -z "$ACTION" ] || [ -z "$FILEPATH" ]; then
                continue
            fi
            # Skip filesize = 0 (hardlinks already handled in a previous loop)
            NBLINKS="${NBLINKS:-0}"
            if [ "$NBLINKS" -gt 1 ] && [ "$FILESIZE" = 0 ]; then
                continue
            fi
            #Prepare RSYNC_CMD
            RSYNC_CMD="rsync --archive --xattrs --relative --hard-links"

            if [ "$TESTMODE" = "yes" ]; then
                RSYNC_CMD+=" --dry-run"
            fi

            # print to debug $SYNCED_FILES $FILEPATH
            #mvDebuglogger "SYNCED_FILES= $SYNCED_FILES" "SYNCED_FILES"
            #mvDebuglogger "FILEPATH= $FILEPATH" "FILEPATH"

            # Check File by validate function and skip if error
            if [ "$VALIDATE_FILENAMES" = "yes" ]; then
                if ! validate_filename "$(basename "$FILEPATH")"; then
                    mvlogger "Error: Invalid filename path: '$FILEPATH'. Please either change the filename to valid or disable the 'Validate input filenames' option." "failure"
                    continue
                #else
                #    mvlogger "Valid filename"
                fi
            fi

            # Get files to rsync:
            SYNCED_FILES=$(grep "|$NBLINKS|$INODE|" "$MOVER_ACTIONLIST" | grep "|$MODIFICATIONTIME|" | grep "ary|$SOURCE|" | cut -d'|' -f13 | while read line; do echo "\"$SOURCE/./$line\""; done | tr '\n' ' ')
            GUI_CURRENT_FILE=$SYNCED_FILES

            # Check if list is complete
            NBFILES=$(($(echo "$SYNCED_FILES" | grep -o '" "' | wc -l) + 1))
            if [ $NBFILES != "$NBLINKS" ]; then
                mvlogger "Expected $NBLINKS files, got $NBFILES. Not moving $SYNCED_FILES to prevent breaking hardlinks"
                continue
            fi

            # Proceed with rsync
            if [[ "$ACTION" =~ "move" ]]; then
                # Some verbosity
                GUI_ACTION="Moving to $DESTINATION/ $([ "$NBLINKS" -gt 1 ] && echo '(preserving hardlinks)')"
                mvlogger "Moving $SYNCED_FILES to  $DESTINATION/ $([ "$NBLINKS" -gt 1 ] && echo '(preserving hardlinks)')"
                rsync_action="Move"
                # Finalize RSYNC_CMD
                RSYNC_CMD+=" --remove-source-files"
            elif [[ "$ACTION" =~ "sync" ]]; then
                # Some verbosity
                GUI_ACTION="Synchronizing to $DESTINATION/ $([ "$NBLINKS" -gt 1 ] && echo '(preserving hardlinks)')"
                mvlogger "Synchronizing  $SYNCED_FILES to  $DESTINATION/ $([ "$NBLINKS" -gt 1 ] && echo '(preserving hardlinks)')"
                rsync_action="Sync"
            fi

            moverStatusWrite

            # Check if action and move files tool is unraid move
            if [[ "$ACTION" =~ "move" && "$MOVE_FILES_TOOL" = "move" ]]; then
                if [ "$TESTMODE" = "yes" ]; then
                    mvlogger "TEST MODE: Would move using Unraid move utility"
                else
                    mvDebuglogger "Move cmd: move, Move file: $SOURCE/$FILEPATH, Dest: $DESTINATION/" "Move Action"
                    # Perform unraid binary move.
                    find "$SOURCE/$FILEPATH" | /usr/libexec/unraid/move "$DEBUGGING" >>"$MOVER_DEBUG_LOG" 2>&1
                fi
            else
                # If action is sync/move and move files tool is rsync
                if [ "$TESTMODE" = "yes" ]; then
                    mvlogger "TEST MODE: Would $rsync_action using rsync utility"
                else
                    mvDebuglogger "Rsync cmd: $RSYNC_CMD, $rsync_action file: $SYNCED_FILES, Dest: $DESTINATION/" "$rsync_action Action"
                    # Perform rsync. relative paths and hardlinks
                    eval "$RSYNC_CMD" "$SYNCED_FILES" "$DESTINATION/"
                fi
            fi

            # Clean parent folder if empty
            if [[ "$ACTION" =~ "move" ]] && [[ "$CLEANFOLDERS" = "yes" || "$CLEANFOLDERS" = "topFolder" ]]; then
                # Define a function to handle the directory cleanup logic
                while IFS= read -r FILE; do
                    DIR=$(dirname "$FILE")
                    mvDebuglogger "Current file: $FILE, Current folder: $DIR, Previous folder: $LAST_DIR, Previous count: $LAST_COUNT" "Clean Folder - Start Loop"

                    if [ -e "${DIR}/.placeholder" ]; then
                        count=".placeholder"
                    else
                        # Check if the current directory is same as the previous one
                        if [ "${LAST_DIR}" == "${DIR}" ]; then
                            # Check if the counter is greater than 0 to avoid counting files in the folder using wc -l
                            if [ "$LAST_COUNT" -gt 0 ]; then
                                count=$((LAST_COUNT - 1))
                                # Save current counter
                                LAST_COUNT="$count"
                            fi
                        else
                            #count=$(ls -A "$DIR" | wc -l)
                            count=$(find "$DIR" -maxdepth 1 -type f | wc -l)
                            # Save current counter
                            LAST_COUNT="$count"
                            # Save current Folder
                            LAST_DIR="$DIR"
                            # echo "Directory changed to: ${DIR}, Count of files: $count"
                        fi
                    fi
                    mvDebuglogger "Cycle of delete folder, Previous count: $LAST_COUNT, Count of files: $count" "Clean Folder - End Loop"

                    if [ "$count" = ".placeholder" ] || [ "$count" != 0 ]; then
                        mvlogger "Not deleting folder containing $count file$([ "$count" != ".placeholder" ] && echo "s"): ${DIR}"
                    else
                        if [ "$TESTMODE" = "no" ]; then
                            mvlogger "Deleting empty folder: ${DIR}"
                            # Check if empty folder exist and remove it
                            [ -d "${DIR}" ] && rmdir "${DIR}"

                            # Clean top level folder if empty
                            if [ "$CLEANFOLDERS" = "topFolder" ]; then
                                # Get the Top-Level Folder of $DIR on share
                                top_folder="$(echo "${DIR}" | cut -d'/' -f1-5)"

                                if [ -e "${top_folder}/.placeholder" ]; then
                                    top_folder_count=".placeholder"
                                else
                                    # Set count to empty by default
                                    top_folder_count=0
                                fi

                                # Count files in Top Folder if exist
                                [ -d "$top_folder" ] && top_folder_count="$(find "$top_folder" -type f | wc -l)"
                                mvDebuglogger "Current top folder: $top_folder, Count of files in Top Folder: $top_folder_count" "Clean Top Folder - Start Loop"

                                if [[ "$top_folder_count" != ".placeholder" && "$top_folder_count" -eq 0 ]]; then
                                    mvlogger "Deleting empty top-level folder: $top_folder"
                                    # Check if empty top-level folder exist and remove it
                                    [ -d "$top_folder" ] && find "$top_folder" -empty -type d -delete
                                else
                                    mvlogger "Not deleting top-level folder containing $top_folder_count file$([ "$count" != ".placeholder" ] && echo "s"): ${top_folder}"
                                fi
                            fi
                        fi
                    fi
                done <<<"$(echo "$SYNCED_FILES" | sed 's|/./|/|g' | xargs -n1 echo)"
            fi

            # Clean parent ZFS dataset if empty
            if [[ "$ACTION" =~ "move" ]] && [ "$TESTMODE" = "no" ] && [ "$CLEANDATASETS" = "yes" ]; then
                # Check counter if equal to 0 then check datasets
                if [ "$LAST_COUNT" -eq 0 ]; then
                    # Count files in share
                    share_file_count=$(find "/mnt/${PRIMARYSTORAGENAME}/${SHARENAME}" -type f | wc -l)
                    mvDebuglogger "Cycle of delete dataset" "Clean Dataset - Start Loop"
                    # If no files in share
                    if [ "${share_file_count}" -eq 0 ]; then
                        # Check if mount point is ZFS
                        if is_zfs_mountpoint_fstype "/mnt/$PRIMARYSTORAGENAME"; then
                            DATASET="${PRIMARYSTORAGENAME}/${SHARENAME}"
                            #echo "Checking if ZFS dataset [${DATASET}] is completely empty..."
                            # If ZFS dataset children size is zero and No ZFS dataset children exist
                            if [ "$(zfs list -Hpo usedbychildren "${DATASET}")" = 0 ] && [ -z "$(zfs list -r -H -o name "${DATASET}" | tail -n +2)" ]; then
                                # Check for any files in the ZFS dataset avalible
                                dataset_file_count=$(find "/mnt/${DATASET}" -type f | wc -l)
                                if [ "${dataset_file_count}" -eq 0 ]; then
                                    mvlogger "ZFS dataset [${DATASET}] appears empty, attempting to unmount and delete..."
                                    zfs unmount "${DATASET}"
                                    if [ $? -ne 0 ]; then
                                        mvlogger "Failed to unmount ZFS dataset [${DATASET}]" "failure"
                                        break
                                    else
                                        mvlogger "ZFS dataset [${DATASET}] has been successfully unmounted."
                                    fi
                                    zfs destroy "${DATASET}"
                                    if [ $? -ne 0 ]; then
                                        mvlogger "Failed to destroy ZFS dataset [${DATASET}]" "failure"
                                        break
                                    else
                                        mvlogger "ZFS dataset [${DATASET}] has been successfully destroyed."
                                    fi
                                else
                                    mvlogger "ZFS dataset [${DATASET}] contains files or directories, will not delete..."
                                fi
                            else
                                mvlogger "ZFS dataset [${DATASET}] contains child datasets, will not delete..."

                            fi
                        fi
                    fi
                fi
            fi

            # Setting mover status
            if [[ "$ACTION" =~ "unattended" ]]; then
                REMAINING_UNATTENDED_SIZE=$((REMAINING_UNATTENDED_SIZE - FILESIZE))
                REMAINING_UNATTENDED_FILES=$((REMAINING_UNATTENDED_FILES - NBLINKS))

                if [[ "$ACTION" =~ "unattended to secondary" ]]; then
                    mvlogger "$REMAINING_UNATTENDED_FILES files remaining from unattended to secondary ($(bytes_to_human "$REMAINING_UNATTENDED_SIZE"))"
                elif [[ "$ACTION" =~ "unattended to primary" ]]; then
                    mvlogger "$REMAINING_UNATTENDED_FILES files remaining from unattended to primary ($(bytes_to_human "$REMAINING_UNATTENDED_SIZE"))"
                fi
            else
                if [[ "$SOURCE" =~ $PRIMARYSTORAGENAME ]]; then
                    REMAINING_CACHE_SIZE=$((REMAINING_CACHE_SIZE - FILESIZE))
                    REMAINING_CACHE_FILES=$((REMAINING_CACHE_FILES - NBLINKS))
                    mvlogger "$REMAINING_CACHE_FILES files remaining from caches to array ($(bytes_to_human "$REMAINING_CACHE_SIZE"))"
                else
                    REMAINING_ARRAY_SIZE=$((REMAINING_ARRAY_SIZE - FILESIZE))
                    REMAINING_ARRAY_FILES=$((REMAINING_ARRAY_FILES - NBLINKS))
                    mvlogger "$REMAINING_ARRAY_FILES files remaining from array to caches ($(bytes_to_human "$REMAINING_ARRAY_SIZE"))"
                fi
            fi
            moverStatusWrite
        done <<<"$(eval "$GREP_CMD")"
    done

    mvlogger "$(titleLine "Cleaning up" '-')"

    if [ "$TESTMODE" != "yes" ] && [ ! -e $SOFTSTOPFILE ] && grep -q "|sync from" "$MOVER_ACTIONLIST"; then
        EPOCH=$(date --date="${NOW:0:4}-${NOW:5:2}-${NOW:8:2} ${NOW:11:2}:${NOW:13:2}:${NOW:15:2}" +%s)

        mvlogger "Set last sync date in config file/s: $EPOCH = $NOW"
        # Check main config and overrides if last sync date exist, then edit or add it to configs
        for config_file in "$MOVERTUNINGCFGFILE" "${MOVERTUNING_OVERRIDE_CFGFOLDER}"/*.cfg; do
            # If config file exist
            if [[ -f "$config_file" ]]; then
                if grep -qs 'synchronizeCache="yes"' "$config_file"; then
                    if grep -q "lastCacheSync=" "$config_file"; then
                        sed -i "s/lastCacheSync=.*$/lastCacheSync=$EPOCH/" "$config_file"
                    else
                        echo "lastCacheSync=$EPOCH" >>"$config_file"
                    fi
                    mvDebuglogger "Sync Cache: $SYNCHRONIZECACHE, Previos CacheSync: $LASTCACHESYNC, New CacheSync: $EPOCH, Config File: $config_file" "Set Last Sync Date to Config"
                fi
            fi
        done
    fi

    if [ $ENABLETURBO = "yes" ]; then
        turbo_write_mode=$(cat /var/local/emhttp/var.ini | grep "md_write_method=" | cut -d'"' -f2)
        mvlogger "Restoring original turbo write mode $( ([ $turbo_write_mode = "auto" ] && echo "Auto (read/modify/write)") || ([ $turbo_write_mode -eq 1 ] && echo "Turbo writes (Reconstruct)") || echo "Read/modify/write")"
        [ $TESTMODE != "yes" ] && /usr/local/sbin/mdcmd set md_write_method $turbo_write_mode
    fi

}

start() {
    [ $LOGLEVEL = 0 ] && echo "Starting Mover tuning plugin.."

    #mvlogger "$(titleLine echo "Mover Tuning Plugin version $(grep -oP 'version=\K[^"]+' "$MOVERTUNINGCFGFILE")" '*')"
    mvlogger "$(titleLine "Mover Tuning Plugin version $(grep "version=" "$MOVERTUNINGCFGFILE" | cut -d '"' -f 2)" '*')"
    # Do not start if already running
    if [ -f $PIDFILE ] && ps h $(cat $PIDFILE) | grep mover; then
        mvlogger "mover: already running" "warning"
        exit 1
    fi
    echo $$ >$PIDFILE

    #Remove any old /var/run/moversoft.stop files
    if [ -e $SOFTSTOPFILE ]; then
        rm $SOFTSTOPFILE
        mvlogger "Mover soft stop file removed."
    fi

    # Only start if config OK
    if [ -f $UNRAIDCFGFILE ]; then
        if grep -qs 'shareMoverLogging="yes"' $UNRAIDCFGFILE; then
            mvlogger "Log Level: $LOGLEVEL"
        fi
    else
        mvlogger "Fatal error: $UNRAIDCFGFILE does not exist, check this." "failure"
        rm $SOFTSTOPFILE
        exit 2
    fi
    if [ -f "$MOVERTUNINGCFGFILE" ]; then
        #Get Mover Tuning Settings
        mvlogger "$(titleLine "Global settings" '-')"
        getMoverSettings "$MOVERTUNINGCFGFILE"
    else
        mvlogger "Fatal error: $MOVERTUNINGCFGFILE does not exist, check this." "failure"
        rm $SOFTSTOPFILE
        exit 3
    fi

    # If $TESTMODE is set to "yes", log a warning message indicating that the test mode is enabled and should be disabled to run the mover.
    if [ "$TESTMODE" = "yes" ]; then
        mvlogger "Warning: Test Mode (dry run) is currently enabled. Please disable it to perform the actual file move."
    fi

    # If $MOVINGPCTTHRESHOLD is equal to $FREEINGPCTLIMIT, log a warning message indicating that the mover will not move due to the thresholds no gap beetween.
    if [ "$MOVINGPCTTHRESHOLD" = "$FREEINGPCTLIMIT" ] && [ "$FREEINGPCTLIMIT" != 0 ]; then
        mvlogger "Warning: Moving thresholds are equal. No action will be taken because the thresholds do not provide a gap."
    fi

    # If $MOVINGPCTTHRESHOLD - $FREEINGPCTLIMIT <= 5, log a warning message indicating that the mover will possibly not move due to the thresholds low gap beetween.
    if [ "$MOVINGPCTTHRESHOLD" -eq "$((FREEINGPCTLIMIT + 5))" ]; then
        mvlogger "Warning: The mover will possibly not proceed due to the low gap between thresholds."
    fi

    # Only start if cache enabled and present
    if ! grep -qs 'shareCacheEnabled="yes"' $UNRAIDCFGFILE && [ $(ls /boot/config/pools/*.cfg | wc -l) -lt 2 ]; then
        mvlogger "Fatal error: cache not enabled and less than 2 pools set up." "failure"
        rm $SOFTSTOPFILE
        exit 4
    fi
    if ! mountpoint -q /mnt/user0 && [ $(ls /boot/config/pools/*.cfg | wc -l) -lt 2 ]; then
        mvlogger "Fatal error: cache not present, or only cache present, and less than 2 pools set up." "failure"
        rm $SOFTSTOPFILE
        exit 5
    fi

    #Delete helper files over 5 days old.
    find "${LOGFOLDER}"/ca.mover.tuning/* -daystart -mtime +"$LISTFILESAGE" -name '*.list' -delete

    #Delete Mover Log and txt files over 10 days old.
    find "${LOGFOLDER}"/ca.mover.tuning/* -daystart -mtime +"$LOGFILESAGE" \( -name '*.log' -o -name '*.txt' \) -delete

    #Delete Mover List files with 0 lines.
    find "${LOGFOLDER}"/ca.mover.tuning/* -size 0 -name '*.list' -delete

    #Let find find hidden files.
    shopt -s nullglob dotglob

    #Run mover before script if specified.
    if [ -n "$BEFORESCRIPT" ] && [ ! -e $SOFTSTOPFILE ]; then
        if [ -f "$BEFORESCRIPT" ] && [ -x "$BEFORESCRIPT" ]; then
            mvlogger "Launching before script: $BEFORESCRIPT"
            eval "$BEFORESCRIPT"
            mvlogger "Before script finished"
        else
            mvlogger "Before script file $BEFORESCRIPT does not exist or is not executable"
            mvlogger "Skipping"
        fi
    fi

    # Proceed with filter and create filtered filelist and action filelist
    [ ! -e $SOFTSTOPFILE ] && createFilteredFilelist
    [ ! -e $SOFTSTOPFILE ] && decideMoveActions

    # Get current time to start time counter
    START_TIME=$(date +"%s")
    mvlogger "Action started at: $(date -d "@$START_TIME" +"%T")"

    # And now.. we move! ... if needed
    [ ! -e $SOFTSTOPFILE ] && [ $TOTALFILES -gt 0 ] && processTheMoves

    mvDebuglogger "processTheMoves completed" "processTheMoves END"

    #Write the final status just for sure
    moverStatusWrite

    mvDebuglogger "moverStatusWrite completed" "moverStatusWrite END"

    #Run mover after script if specified.
    if [ -n "$AFTERSCRIPT" ] && [ ! -e "$SOFTSTOPFILE" ]; then
        if [ -f "$AFTERSCRIPT" ] && [ -x "$AFTERSCRIPT" ]; then
            mvlogger "Launching after script: $AFTERSCRIPT"
            eval "$AFTERSCRIPT"
            mvlogger "After script finished with result: $([ $? = 0 ] && echo "OK" || echo "$?")"
        else
            mvlogger "After script file $AFTERSCRIPT does not exist or is not executable."
            mvlogger "Skipping"
        fi
    fi

    mvDebuglogger "after script completed" "after script END"

    #Reset run-once settings
    if [ ! -e $SOFTSTOPFILE ]; then
        for config_file in "$MOVERTUNINGCFGFILE" "${MOVERTUNING_OVERRIDE_CFGFOLDER}"/*.cfg; do
            # If config file exist
            if [ -f "$config_file" ]; then
                resetRunOnceMoverSettings "$config_file"
            fi
        done
    fi

    mvDebuglogger "Reset run-once settings completed" "run-once settings END"

    mvlogger "Cleaning lock and stop files"
    for file in $PIDFILE $SOFTSTOPFILE; do
        [[ -e "$file" ]] && rm -f "$file"
    done

    mvDebuglogger "Cleaning lock and stop files completed" "Cleaning lock and stop files END"

    # Calculate Elapsed Time
    STOP_TIME=$(date +"%s")
    ELAPSED_SECONDS=$((STOP_TIME - START_TIME))
    mvlogger "Action ended at: $(date -d "@$STOP_TIME" +"%T")"

    # Convert elapsed seconds to days, hours, minutes, and seconds
    DAYS=$((ELAPSED_SECONDS / 86400))
    HOURS=$(((ELAPSED_SECONDS % 86400) / 3600))
    MINUTES=$(((ELAPSED_SECONDS % 3600) / 60))
    SECONDS=$((ELAPSED_SECONDS % 60))

    # Format the elapsed time
    ELAPSED_TIME=""

    if [ "$DAYS" -gt 0 ]; then
        ELAPSED_TIME+=" ${DAYS} day$([ "$DAYS" -ne 1 ] && echo 's')"
    fi

    if [ "$HOURS" -gt 0 ]; then
        ELAPSED_TIME+=" ${HOURS} hr$([ "$HOURS" -ne 1 ] && echo 's')"
    fi

    if [ "$MINUTES" -gt 0 ]; then
        ELAPSED_TIME+=" ${MINUTES} min$([ "$MINUTES" -ne 1 ] && echo 's')"
    fi

    if [[ "$SECONDS" -gt 0 || "$SECONDS" -eq 0 && "$ELAPSED_SECONDS" -eq 0 ]]; then
        ELAPSED_TIME+=" ${SECONDS} sec"
    fi

    mvlogger "Elapsed time:$ELAPSED_TIME"
    mvlogger "$(titleLine 'WE ARE DONE !' '*')"

    if [ "$TESTMODE" = "yes" ]; then
        if [ "$TOTALFILES" -gt 0 ]; then
            unraid_notify "TEST MODE: A total of $TOTALFILES files representing $(bytes_to_human "$TOTALSIZE") would be moved/synced by Mover Tuning plugin. Elapsed time: $ELAPSED_TIME" "warning"
        else
            unraid_notify "TEST MODE: No files would be moved/synced by Mover Tuning plugin. Elapsed time: $ELAPSED_TIME" "warning"
        fi
    else
        if [ "$TOTALFILES" -gt 0 ]; then
            unraid_notify "A total of $TOTALFILES files representing $(bytes_to_human "$TOTALSIZE") were successfully moved/synced by Mover Tuning plugin. Elapsed time: $ELAPSED_TIME" "success"
        else
            unraid_notify "No files were moved/synced by Mover Tuning plugin. Elapsed time: $ELAPSED_TIME" "success"
        fi
    fi

    [ $LOGLEVEL = 0 ] && echo "Mover tuning plugin done!"
}

reset() {
    # Reset to default config file
    echo "mover: Cleaning the configuration file to default values and removing any override configurations."

    if [ -e "$MOVERTUNINGCFGFILE" ]; then
        rm -f "$MOVERTUNINGCFGFILE"
    fi
    # Also delete override configs folder
    rm -rf "$MOVERTUNING_OVERRIDE_CFGFOLDER"
    # Copy default config
    cp -a "$MOVERTUNING_DEFAULT_CFGFILE" "$MOVERTUNINGCFGFILE"
    exit
}

debug() {
    # creating plugin diagnostics file at /boot/logs/Mover Tuning Debug Package (.zip)"
    echo "move: Starting Mover Tuning Plugin diagnostics collection..."
    /usr/local/emhttp/plugins/ca.mover.tuning/debug_mover >/dev/null 2>&1
    echo "move: done. ZIP file at /boot/logs/ca.mover.tuning-debug-<date-time>.zip created."
}

empty() {
    DISK="$1"

    if [ -f $PIDFILE ]; then
        if ps h $(cat $PIDFILE) | grep mover; then
            echo "mover: already running"
            exit 1
        fi
    fi

    echo $$ >/var/run/mover.pid
    echo "mover: started"

    shopt -s nullglob

    # we can only empty share directories
    for SHAREPATH in /mnt/$DISK/*; do
        SHARE=$(basename "$SHAREPATH")
        if [[ -d "$SHAREPATH" && -f "$CFGPATH/$SHARE.cfg" ]]; then
            move "$SHAREPATH" "-e"
        fi
    done

    # output list of files which could not be moved
    # use 'find' in case huge number of files left in /mnt/$DISK
    count=$(find /mnt/$DISK -mindepth 1 | wc -l)
    if [ "$count" -gt 0 ]; then
        find /mnt/$DISK -mindepth 1 -depth -printf 'move: %p Not moved\n' | head -n 100
        if [ "$count" -gt 100 ]; then
            echo "[output truncated to first 100 entries]"
        fi
    fi

    rm -f $PIDFILE
    echo "mover: finished"
}

killtree() {
    local pid=$1 child

    for child in $(pgrep --ns $$ -P $pid); do
        killtree $child
    done
    [ $pid -ne $$ ] && kill -TERM $pid
}

# Caution: stopping mover like this can lead to partial files on the destination
# and possible incomplete hard link transfer.  Not recommended to do this.
stop() {
    if [ ! -f $PIDFILE ]; then
        echo "mover: not running"
        exit 0
    fi
    killtree $(cat $PIDFILE)
    sleep 2
    rm -f $PIDFILE
    echo "mover: stopped"
    exit
}

softstop() {
    echo "Soft Stop Requested"
    if [ ! -f $PIDFILE ]; then
        echo "mover: not running"
        exit 0
    fi
    touch $SOFTSTOPFILE
    exit
}

# Function to display usage
usage() {
    echo "Mover Tuning Plugin version $(grep "version=" "$MOVERTUNINGCFGFILE" | cut -d '"' -f 2)"
    echo
    echo "Usage:"
    echo "  $0 | mover start [-e <disk_name>]"
    echo "  $0 | mover stop | softstop | status | reset | debug"
    echo
    echo "Notes:"
    echo "  <disk_name> must match the pattern 'disk[0-9]*' and /mnt/<disk_name> must be a mounted disk."
    echo
    echo "Commands:"
    echo "  start    - Start mover. Use 'start -e <disk_name>' to empty a disk."
    echo "  stop     - Forced stop mover."
    echo "  softstop - Soft stop mover. (Recommended)"
    echo "  status    - Check if the mover is running."
    echo "  reset    - Reset plugin config to default values and delete the override config folder."
    echo "  debug    - Create plugin diagnostics ZIP at /boot/logs/ca.mover.tuning-debug-<date-time>.zip"
    exit 1
}

# validate disk name
validate_disk() {
    if [[ ! "$1" =~ ^disk[0-9]+$ ]]; then
        echo "Error: <disk_name> must match pattern 'disk[0-9]+$'"
        usage
    fi
    if ! mountpoint --nofollow /mnt/$1 >/dev/null 2>&1; then
        echo "Error: nothing mounted at /mnt/$1"
        usage
    fi
}

status() {
    if [ -f $PIDFILE ]; then
        echo "mover: running"
        cat $PIDFILE
        exit 0
    else
        echo "mover: not running"
    fi
    exit
}

if [ "$#" -lt 1 ]; then
    usage
    exit 1
fi

case $1 in
start)
    if [ -z "$2" ]; then
        start
    elif [ "$2" == "-e" ]; then
        if [ -z "$3" ]; then
            usage
        else
            validate_disk "$3"
            empty "$3"
        fi
    else
        usage
    fi
    ;;
stop)
    stop
    ;;
softstop)
    softstop
    ;;
status)
    status
    ;;
reset)
    reset
    ;;
debug)
    debug
    ;;
*)
    usage
    ;;
esac

# That's all folks :)
